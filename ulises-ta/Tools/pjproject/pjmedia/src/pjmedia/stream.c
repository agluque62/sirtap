/* $Id: stream.c 2761 2009-06-13 15:51:30Z nanang $ */
/* 
 * Copyright (C) 2008-2009 Teluu Inc. (http://www.teluu.com)
 * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */
#include <qos2.h>
#include <pjmedia/stream.h>
#include <pjmedia/errno.h>
#include <pjmedia/rtp.h>
#include <pjmedia/rtcp.h>
#include <pjmedia/jbuf.h>
#include <pjmedia/echo.h>
#include <pj/array.h>
#include <pj/assert.h>
#include <pj/ctype.h>
#include <pj/compat/socket.h>
#include <pj/errno.h>
#include <pj/ioqueue.h>
#include <pj/log.h>
#include <pj/os.h>
#include <pj/pool.h>
#include <pj/rand.h>
#include <pj/sock_select.h>
#include <pj/string.h>	    /* memcpy() */
#include <pj/lock.h>
#include <pj/timer.h>

#define THIS_FILE			"stream.c"
#define ERRLEVEL			1
#define LOGERR_(expr)			stream_perror expr
#define TRC_(expr)			PJ_LOG(5,expr)

#define BYTES_PER_SAMPLE		2
#define PTT_REP_COUNT			(2)

#define STREAM_MAX_LATENCY_TIMER_HEAP 64

/* Limit the number of synthetic audio samples that are generated by PLC.
 * Normally PLC should have it's own means to limit the number of
 * synthetic frames, so we need to set this to a reasonably large value
 * just as precaution
 */
#define MAX_PLC_MSEC			PJMEDIA_MAX_PLC_DURATION_MSEC

/**
 * Media channel.
 */
struct pjmedia_channel
{
    pjmedia_stream	   *stream;	    /**< Parent stream.		    */
    pjmedia_dir		    dir;	    /**< Channel direction.	    */
    unsigned		    pt;		    /**< Payload type.		    */
    pj_bool_t		    paused;	    /**< Paused?.		    */
    unsigned		    out_pkt_size;   /**< Size of output buffer.	    */
    void		   *out_pkt;	    /**< Output buffer.		    */
    pjmedia_rtp_session	    rtp;	    /**< RTP session.		    */
};


struct dtmf
{
    int		    event;
    pj_uint32_t	    duration;
};

typedef struct _IMPAIREDATA {

	/*Parametros para Impairments (degradas el stream. Necesario para el ETM*/
	int Perdidos;
	int Duplicados;
	int LatMin;
	int LatMax;

	int LatMax_prev;

	pj_timer_heap_t* p_timerheap_latency;		//Timer para enviar los paquetes con latencia
	pj_timer_entry timer_entry_latency[STREAM_MAX_LATENCY_TIMER_HEAP];
	int timer_entry_latency_count;
	pj_thread_t* platency_thread;
	pj_bool_t platency_thread_quit;
} IMPAIREDATA;

/**
 * This structure describes media stream.
 * A media stream is bidirectional media transmission between two endpoints.
 * It consists of two channels, i.e. encoding and decoding channels.
 * A media stream corresponds to a single "m=" line in a SDP session
 * description.
 */
struct pjmedia_stream
{
	pjmedia_endpt* endpt;	    /**< Media endpoint.	    */
	pjmedia_codec_mgr* codec_mgr;	    /**< Codec manager instance.    */

	pjmedia_port	     port;	    /**< Port interface.	    */
	pjmedia_channel* enc;	    /**< Encoding channel.	    */
	pjmedia_channel* dec;	    /**< Decoding channel.	    */

	pjmedia_dir		     dir;	    /**< Stream direction.	    */
	void* user_data;	    /**< User data.		    */
	pj_str_t		     cname;	    /**< SDES CNAME		    */

	pjmedia_transport* transport;	    /**< Stream transport.	    */

	pjmedia_codec* codec;	    /**< Codec instance being used. */
	pjmedia_codec_param	     codec_param;   /**< Codec param.		    */
	pj_int16_t* enc_buf;	    /**< Encoding buffer, when enc's
						 ptime is different than dec.
						 Otherwise it's NULL.	    */

	unsigned		     enc_samples_per_pkt;
	unsigned		     enc_buf_size;  /**< Encoding buffer size, in
						 samples.		    */
	unsigned		     enc_buf_pos;   /**< First position in buf.	    */
	unsigned		     enc_buf_count; /**< Number of samples in the
						 encoding buffer.	    */

	unsigned		     plc_cnt;	    /**< # of consecutive PLC frames*/
	unsigned		     max_plc_cnt;   /**< Max # of PLC frames	    */

	unsigned		     vad_enabled;   /**< VAD enabled in param.	    */
	unsigned		     frame_size;    /**< Size of encoded base frame.*/
	pj_bool_t		     is_streaming;  /**< Currently streaming?. This
						 is used to put RTP marker
						 bit.			    */
	pj_uint32_t		     ts_vad_disabled;/**< TS when VAD was disabled. */
	pj_uint32_t		     tx_duration;   /**< TX duration in timestamp.  */

	pj_mutex_t* jb_mutex;
	pjmedia_jbuf* jb;	    /**< Jitter buffer.		    */
	char		     jb_last_frm;   /**< Last frame type from jb    */
	unsigned		     jb_last_frm_cnt;/**< Last JB frame type counter*/

	pjmedia_rtcp_session     rtcp;	    /**< RTCP for incoming RTP.	    */

	pj_uint32_t		     rtcp_last_tx;  /**< RTCP tx time in timestamp  */
	pj_uint32_t		     rtcp_interval; /**< Interval, in timestamp.    */
	pj_bool_t		     initial_rr;    /**< Initial RTCP RR sent	    */

	/* RFC 2833 DTMF transmission queue: */
	int			     tx_event_pt;   /**< Outgoing pt for dtmf.	    */
	int			     tx_dtmf_count; /**< # of digits in tx dtmf buf.*/
	struct dtmf		     tx_dtmf_buf[32];/**< Outgoing dtmf queue.	    */

	/* Incoming DTMF: */
	int			     rx_event_pt;   /**< Incoming pt for dtmf.	    */
	int			     last_dtmf;	    /**< Current digit, or -1.	    */
	pj_uint32_t		     last_dtmf_dur; /**< Start ts for cur digit.    */
	unsigned		     rx_dtmf_count; /**< # of digits in dtmf rx buf.*/
	char		     rx_dtmf_buf[32];/**< Incoming DTMF buffer.	    */

	/* DTMF callback */
	void		    (*dtmf_cb)(pjmedia_stream*, void*, int);
	void* dtmf_cb_user_data;

#if defined(PJMEDIA_HANDLE_G722_MPEG_BUG) && (PJMEDIA_HANDLE_G722_MPEG_BUG!=0)
	/* Enable support to handle codecs with inconsistent clock rate
	 * between clock rate in SDP/RTP & the clock rate that is actually used.
	 * This happens for example with G.722 and MPEG audio codecs.
	 */
	pj_bool_t		     has_g722_mpeg_bug;
	/**< Flag to specify whether
	 normalization process
	 is needed		    */
	unsigned		     rtp_tx_ts_len_per_pkt;
	/**< Normalized ts length per packet
	 transmitted according to
	 'erroneous' definition	    */
	unsigned		     rtp_rx_ts_len_per_frame;
	/**< Normalized ts length per frame
	 received according to
	 'erroneous' definition	    */
	pj_uint32_t		     rtp_rx_last_ts;/**< Last received RTP timestamp
						 for timestamp checking	    */
	unsigned		     rtp_rx_last_cnt;/**< Nb of frames in last pkt  */
	unsigned		     rtp_rx_check_cnt;
	/**< Counter of remote timestamp
	 checking */
#endif

#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)
	pj_uint32_t		     rtcp_xr_last_tx;  /**< RTCP XR tx time
								in timestamp.           */
	pj_uint32_t		     rtcp_xr_interval; /**< Interval, in timestamp. */
	pj_sockaddr		     rtcp_xr_dest;     /**< Additional remote RTCP XR
							dest. If sin_family is
							zero, it will be ignored*/
	unsigned		     rtcp_xr_dest_len; /**< Length of RTCP XR dest
								address		    */
#endif

	unsigned ka_type;
	unsigned ka_remote_timeout;
	unsigned ka_local_interval;
	pj_bool_t ka_received;
	pj_bool_t ka_send;				//Se ha enviado un keep-alive. Se pone a false cuando se envia un rtp de audio
	pj_bool_t ka_disabled;			//Si es true entonces se desactiva el envio de keepalives

	pj_timestamp last_frm_ts_sent; /**< Timestamp of last sending packet		    */
	pj_timestamp last_vf_ts_received;

	pj_bool_t rtp_ext_enabled;
	pj_bool_t rtp_ext_received;
	pj_uint32_t rtp_ext_tx_info;
	pj_uint32_t last_ext_header[16];	//Guarda la �ltima extensi�n de cabecera recibida
	pj_uint32_t last_rtp_ext_length;	//Guarda la �ltima longitud de la extensi�n de cabecera recibida
	int reenv_info_count;

	pjmedia_echo_state* p_echo;
	pj_lock_t* p_echo_lock;

	/** AGL. EL PTT-ID para los KEEP */
	unsigned short pttId;

	pj_bool_t NTP_synchronized;	//Indica el estado de sincronizacion NTP
	pj_bool_t request_MAM;		//Cuando este flag est� a true entonces en el siguiente rtp (keep-alive o audio) se env�a el RMM solicitando el MAM
	pj_uint32_t last_T1;		//Ultimo T1 enviado en el RMM. Cuando se crea el stream entonces valdr� 0
	pj_uint32_t PTT_rep_count;
	pj_uint32_t SQU_rep_count;
	pj_uint32_t SQU_rep;
	pj_uint32_t audio_flags;		//Toma valores del tipo Stream_CallFlags
	pj_bool_t radio_ua;			//Si vale TRUE entonces somos una radio. Seguramente de un simulador de radio
	pj_bool_t ka_forced;		//Si vale TRUE entonces la siguiente vez que entre la funcion put_frame_imp se fuerza a enviar un keep_alive
	pj_bool_t tx_pttmute_changed;	//Si false true indica que el bit de mute a transmitir ha cambiado. 
	pj_bool_t force_no_send_rtp;	//Si true indica que se fuerza que no se envie RTP en ningun caso.

	pj_bool_t send_MAM;
	pj_uint32_t mam_T1;
	pj_uint32_t mam_T2;
	pj_uint16_t mam_Tj1;
	pj_uint16_t mam_Tid;
	pj_uint16_t mam_Ts2;
	pj_mutex_t* mam_mutex;

	/*Parametros que se fuerzan en el RTPRx*/
	pj_bool_t GRS_force_ptt_in_RTPRx;					//Si vale true fuerza solo el valor de PTT mute en el RTPRx
	pj_bool_t GRS_force_ptt_mute_in_RTPRx;				//Si vale true fuerza el valor de PTT mute en el RTPRx y tambien el del PTT
	pj_uint32_t GRS_forced_ptt_type_value_in_RTPRx;
	pj_uint32_t GRS_forced_ptt_id_value_in_RTPRx;
	pj_bool_t GRS_force_ptt_in_RTPRx_confirmed;	//Si vale true entonces el mute se confirma al cumplir PTT lockout y summation

	pj_bool_t GRS_force_SCT_in_RTPRx;			//Si vale true fuerza el valor
	pj_bool_t Force_PTTS_in_RTPTxRx;			//Si vale true fuerza el valor

	pj_bool_t SelCalInProgress;					//Si vale true indica que un Selcal se esta simulando

	HANDLE QoSHandle;

	char ED137version;			//Vale 'B' ED137B o 'C' ED137C
	
	IMPAIREDATA ImpDat;
	pj_lock_t* p_latency_lock;

	pj_bool_t is_for_coresip_RTPport;			//Si es true indica que es un stream para un objeto RTPport, no es de una sesion SIP normal.
};

typedef struct _MYDATA {
   HANDLE timer;
   pjmedia_stream *stream;
   void *pkt;
   pj_size_t size;
} MYDATA;

unsigned gJBufPframes = 4;

/* Parametros que definen el buffer de jitter del agente*/
unsigned pjmedia_stream_jitter_buffer_force = 0;				//Fuerza los parametros del buffer de jitter
unsigned pjmedia_stream_jitter_buffer_max_count = 4;			//Capacidad maxima del buffer de Jitter
unsigned pjmedia_stream_jitter_buffer_adaptive = 1;				//Si es distinto de cero, entonces el buffer es adaptativo, si es 0 entonces es fijo
unsigned pjmedia_stream_jitter_buffer_prefetch = 0;				//Prefetch del buffer de jitter.
																//Si es adaptativo: The initial prefetch value to be applied to the jitter buffer. 
																//Setting this to other than 0 will activate prefetch buffering, 
																//a jitter buffer feature that each time it gets empty, 
																//it won't return a normal frame until its size reaches the number specified here.
																//Si es fijo: The fixed delay value, in number of frames.
unsigned pjmedia_stream_jitter_buffer_min_prefetch = 1;			//Para buffer adaptativo: The minimum delay that must be applied to each incoming packets, in number of frames.
unsigned pjmedia_stream_jitter_buffer_max_prefetch = 2;			//Para buffer adaptativo: The maximum allowable value for prefetch delay, in number of frames.
unsigned pjmedia_stream_jitter_buffer_discard = 1;				//Para buffer adaptativo(en fijo se ignora) :
																//Si su valor es distinto de cero, buffer descarta paquetes para minimizar el retardo progresivamente.
																//Si su valor es cero entonces no se descarta ningun paquete.
																//En cualquiera de los casos, cuando el buffer se llena se descarta un paquete.																

/* RFC 2833 digit */
static const char digitmap[16] = { '0', '1', '2', '3', 
				   '4', '5', '6', '7', 
				   '8', '9', '*', '#',
				   'A', 'B', 'C', 'D'};

/* Zero audio frame samples */
static pj_int16_t zero_frame[2 * 30 * 16000 / 1000];

/*
 * Print error.
 */
static void stream_perror(const char *sender, const char *title,
			  pj_status_t status)
{
    char errmsg[PJ_ERR_MSG_SIZE];

    pj_strerror(status, errmsg, sizeof(errmsg));
    PJ_LOG(4,(sender, "%s: %s [err:%d]", title, errmsg, status));
}

/*
 * Retorna el Timestamp T en le formato necesario para el climax
*/
PJ_DEF(unsigned long long) pjmedia_stream_GetTimeClimax(void)
{
	FILETIME SystemTimeAsFileTime;
	unsigned long long T1;
	unsigned long long T1_segundos;

	GetSystemTimeAsFileTime(&SystemTimeAsFileTime);  //Retorna el tiempo en unidades de 100ns

	//T1 en unidades de 100ns. En formato FILETIME. Desde 0 horas 1/1/1601
	T1 = (unsigned long long) SystemTimeAsFileTime.dwHighDateTime;
	T1 <<= 32;
	T1 |= (unsigned long long) SystemTimeAsFileTime.dwLowDateTime;

	//Se le resta el tiempo en unidades de 100ns desde 0 horas 1/1/1601 a 0 horas 1/1/1900
	//Para convertirlo en NTP timestamp
	T1 -= (unsigned long long) 94354848000000000;

	T1_segundos = T1 / 10000000;   //Timestamp en segundos. Ser�an los 32bits de mayor peso de un NTP timestamp de 64 bits
	T1 -= T1_segundos * 10000000;  //A T1 le restamos la cantidad de segundos pero en unidades de 100ns
											//obteniedo la fraccion de segundos en unidades de 100ns			
	T1_segundos &= 0x3FF;		   //Nos quedamos con los 10 de manor peso, que sumados a 32 nos quedar�amos con 42
	T1 = T1_segundos * 10000000 + T1; //Le volvermos a sumar los segundos ya truncados.
	T1 /= 1250;						//T1 En unidades de 125 us
	T1 &= 0x7FFFFF;				//Nos quedamos con 23 bits

	return T1;
}

static void add_mam_packet(pjmedia_stream* stream, char * pstart, pj_uint32_t ext_val, 
	pj_uint32_t mam_T1, pj_uint32_t mam_T2, pj_uint16_t mam_Tj1, pj_uint16_t mam_Tid, pj_uint16_t mam_Ts2)
{
	int i;
	pj_uint8_t buf[4];
	pj_uint8_t value = 0;
	pj_uint32_t v32t = 0;
	pj_uint32_t mam_T3;

	mam_T3 = (pj_uint32_t)pjmedia_stream_GetTimeClimax();

	//Se env�a solo el MAM
	PJMEDIA_RTP_RD_EX_SET_X(ext_val, 1);

	//Se env�a mensaje MAM. Type 4, length 12, 1 bit TQG, 23 bits T1, 1 bit MMR, 23 bits T2, 16 bits Tsd, 16 bits Tj1, 16 bits Tid

	//Type 4 (4 bits), length 12 (4 bits),  1 bit TQG (1 bit), 7 bits mayor peso de T1 = 8 bits del Value
	PJMEDIA_RTP_RD_EX_SET_TYPE(ext_val, 0x4);

	if (stream->ED137version == 'C')
		PJMEDIA_RTP_RD_EX_SET_LENGTH(ext_val, 0xE);		//En ED137C length es 14
	else
		PJMEDIA_RTP_RD_EX_SET_LENGTH(ext_val, 0xC);		//En ED137C length es 12

	value = (pj_uint8_t)(mam_T1 >> 16);
	if (stream->NTP_synchronized) value |= 0x80;  //TQG
	else value &= ~0x80;

	//TRC_((THIS_FILE, "TRAZA: value %d (0x%X)", value, value));

	PJMEDIA_RTP_RD_EX_SET_VALUE(ext_val, value);
	pj_memcpy(pstart, &ext_val, sizeof(pj_uint32_t));

	//16 bits de menor peso de T1 + 1 bit MMR + 15 bits mayor peso de T2 = 32 bits

	//16 bits de menor peso de T1
	ext_val = (pj_uint32_t)mam_T1;
	ext_val &= (pj_uint32_t)0xFFFF;
	ext_val <<= 16;

	//NMR = 0; Saltamos un bit			
	//15 bits de mayor peso de T2
	v32t = (pj_uint32_t)(mam_T2 >> 8);
	v32t &= 0x7FFF;
	ext_val |= v32t;

	for (i = 0; i < 4; i++)
	{
		buf[i] = (pj_uint8_t)(ext_val >> (24 - i * 8));
	}

	pj_memcpy(pstart + sizeof(pj_uint32_t), buf, sizeof(pj_uint32_t));

	//8 bits de menor peso de T2 + 16 bits de Tsd + 8 bits de mayor peso de Tj1 = 32 bits

	//8 bits de menor peso de T2
	ext_val = ((pj_uint32_t)mam_T2) & 0xFF;
	ext_val = ext_val << 24;

	//16 bits de Tsd=T3-T2			
	pj_uint32_t Tsd = mam_T3 - mam_T2;
	Tsd <<= 8;
	ext_val |= Tsd;

	//8 bits de mayor peso de Tj1
	v32t = (pj_uint32_t)mam_Tj1;
	v32t &= 0xFFFF;
	v32t >>= 8;
	ext_val |= v32t;

	for (i = 0; i < 4; i++)
	{
		buf[i] = (pj_uint8_t)(ext_val >> (24 - i * 8));
	}

	pj_memcpy(pstart + sizeof(pj_uint32_t) * 2, &buf, sizeof(pj_uint32_t));

	//8 bits menor peso Tj1 + 16 bits Tid + 8 bits a cero = 32 bits

	//8 bits menor peso Tj1
	ext_val = (pj_uint32_t)mam_Tj1;
	ext_val <<= 24;

	//16 bits Tid
	v32t = (pj_uint32_t)mam_Tid;
	v32t <<= 8;
	ext_val |= v32t;

	if (stream->ED137version == 'C')
	{
		//8 bits mayor peso Ts2
		v32t = (pj_uint32_t)mam_Ts2;
		v32t >>= 8;
		ext_val |= v32t;
	}

	for (i = 0; i < 4; i++)
	{
		buf[i] = (pj_uint8_t)(ext_val >> (24 - i * 8));
	}

	pj_memcpy(pstart + sizeof(pj_uint32_t) * 3, &buf, sizeof(pj_uint32_t));

	if (stream->ED137version == 'C')
	{
		//8 bits menor peso Ts2
		v32t = (pj_uint32_t)mam_Ts2;
		v32t <<= 24;
		ext_val = v32t;

		for (i = 0; i < 4; i++)
		{
			buf[i] = (pj_uint8_t)(ext_val >> (24 - i * 8));
		}

		pj_memcpy(pstart + sizeof(pj_uint32_t) * 4, &buf, sizeof(pj_uint32_t));
	}
}

static void add_rmm_packet(pjmedia_stream* stream, char* pstart, pj_uint32_t ext_val)
{
	unsigned long long T1;
	pj_uint8_t value = 0;
	int i;
	pj_uint8_t buf[4];

	T1 = pjmedia_stream_GetTimeClimax();

	//Se env�a solo el RMM
	PJMEDIA_RTP_RD_EX_SET_X(ext_val, 1);

	//Se env�a mensaje RMM. Type 4, length 3, 1 bit TQV, 23 bits T1 			
	PJMEDIA_RTP_RD_EX_SET_TYPE(ext_val, 0x4);
	PJMEDIA_RTP_RD_EX_SET_LENGTH(ext_val, 0x3);

	//TRC_((THIS_FILE, "TRAZA: Envio T1 %lld (0x%llX)", T1, T1));

	value = (pj_uint8_t)(T1 >> 16);

	if (stream->NTP_synchronized) value |= 0x80;  //TQV
	else value &= ~0x80;

	//TRC_((THIS_FILE, "TRAZA: value %d (0x%X)", value, value));

	PJMEDIA_RTP_RD_EX_SET_VALUE(ext_val, value);

	pj_memcpy((char*)pstart, &ext_val, sizeof(pj_uint32_t));

	ext_val = (pj_uint32_t)T1;
	ext_val &= (pj_uint32_t)0xFFFF;

	//TRC_((THIS_FILE, "TRAZA: ext_val %d (0x%X)", ext_val, ext_val));

	ext_val <<= 16;

	for (i = 0; i < 4; i++)
	{
		buf[i] = (pj_uint8_t)(ext_val >> (24 - i * 8));
	}

	pj_memcpy((char*)pstart + sizeof(pj_uint32_t), buf, sizeof(pj_uint32_t));

	stream->request_MAM = PJ_FALSE;
	stream->last_T1 = (pj_uint32_t)T1;
}

/*
 * Send keep-alive packet.
 */
static void send_keep_alive_packet(pjmedia_stream *stream, int ts_len)
{
	if (stream->ka_disabled) return;

	if (stream->ka_type == PJMEDIA_STREAM_KA_R2S)
	{
		pj_status_t status;
		void *rtphdr;
		int pkt_len;
		pj_uint32_t ext_val;
		pj_bool_t req_MAM = PJ_FALSE;
		pj_uint32_t mam_T1 = 0; 
		pj_uint32_t mam_T2 = 0; 
		pj_uint16_t mam_Tj1 = 0;
		pj_uint16_t mam_Tid = 0;
		pj_uint16_t mam_Ts2 = 0;
		pj_bool_t send_MAM = PJ_FALSE;		
		pj_uint32_t current_reserved;

		/** AGL 140528. Cabercera para ED137A */
		pj_uint32_t ext_hdr = 0x01006701;	// 0x01006700;

		ext_val = stream->rtp_ext_tx_info;
		if ((stream->radio_ua == PJ_FALSE) && (!(stream->audio_flags & STREAM_PTTID_ENABLED)))
		{
			//Si es VCS y no hay PTT-id distinto de cero, quiere decir que no podemos enviar PTT
			PJMEDIA_RTP_RD_EX_SET_PTT_TYPE(ext_val, 0);
			PJMEDIA_RTP_RD_EX_SET_PM(ext_val, 0);
		}
		else if (stream->audio_flags & STREAM_IDLE)
		{
			if (stream->radio_ua == PJ_FALSE)
			{
				PJMEDIA_RTP_RD_EX_SET_PTT_TYPE(ext_val, 0);
				PJMEDIA_RTP_RD_EX_SET_PM(ext_val, 0);
			}
			else
			{
				//Cuando la radio esta en estado IDLE, entonces el GRS envia solo estados de SQU, exepto si es un transmisor
				PJMEDIA_RTP_RD_EX_SET_PTT_TYPE(ext_val, 0);
				if (stream->audio_flags & STREAM_TXONLY)
				{
					PJMEDIA_RTP_RD_EX_SET_SQU(ext_val, 0);
				}
				PJMEDIA_RTP_RD_EX_SET_PM(ext_val, 0);
			}
		}
		else
		{
			if (stream->radio_ua == PJ_TRUE)
			{
				//Somos una radio que no esta en modo IDLE, no señalizamos el SQUELCH en los Keepalives sin audio
				PJMEDIA_RTP_RD_EX_SET_SQU(ext_val, 0);
				if (PJMEDIA_RTP_RD_EX_GET_TYPE(ext_val) == 1)
				{
					//Estabamos enviando el QIDX. Lo quitamos.
					PJMEDIA_RTP_RD_EX_SET_X(ext_val, 0);
					PJMEDIA_RTP_RD_EX_SET_TYPE(ext_val, 0);
					PJMEDIA_RTP_RD_EX_SET_LENGTH(ext_val, 0);
					PJMEDIA_RTP_RD_EX_SET_VALUE(ext_val, (0));
				}
			}
		}

		/** PTT-ID para el KA */
		if (stream->audio_flags & STREAM_PTTID_ENABLED)
		{
			PJMEDIA_RTP_RD_EX_SET_PTT_ID(ext_val, stream->pttId);
		}
		else
		{
			PJMEDIA_RTP_RD_EX_SET_PTT_ID(ext_val, 0);
		}

		req_MAM = stream->request_MAM;
		if (req_MAM)
		{
			//Si pedimos MAM tenemos que enviar un length de 2
			ext_hdr = 0x02006701;
		}
		else
		{
			//Si se va a enviar un RMM entonces esperariamos a enviar el MAM en el siguiente paquete si send_MAM es true

			pj_mutex_lock(stream->mam_mutex);
			mam_T1 = stream->mam_T1;
			mam_T2 = stream->mam_T2;
			mam_Tj1 = stream->mam_Tj1;
			mam_Tid = stream->mam_Tid;
			mam_Ts2 = stream->mam_Ts2;
			send_MAM = stream->send_MAM;
			stream->send_MAM = PJ_FALSE;
			pj_mutex_unlock(stream->mam_mutex);

			if (send_MAM)
			{
				if (stream->ED137version == 'C')
					ext_hdr = 0x05006701;			//El MAM son 5 palabras de 32 bits en ED137C
				else
					ext_hdr = 0x04006701;			//El MAM son 4 palabras de 32 bits en ED137B
			}
		}

		PJMEDIA_RTP_RD_EX_SET_VF(ext_val, stream->rtp_ext_received);
		stream->rtp_ext_received = PJ_FALSE;

		/*Aqui ponemos los valores forzados si procede*/		
		if (stream->radio_ua == PJ_TRUE)
		{
			pj_uint32_t current_squ;
			pj_uint32_t current_ptt_id;
		
			current_squ = PJMEDIA_RTP_RD_EX_GET_SQU(ext_val);
			current_ptt_id = PJMEDIA_RTP_RD_EX_GET_PTT_ID(ext_val);
			if (stream->GRS_force_ptt_in_RTPRx_confirmed &&
				current_squ == 0 &&
				current_ptt_id != 0)
			{
				if (stream->GRS_force_ptt_mute_in_RTPRx) PJMEDIA_RTP_RD_EX_SET_PM(ext_val, 1);
				PJMEDIA_RTP_RD_EX_SET_PTT_TYPE(ext_val, stream->GRS_forced_ptt_type_value_in_RTPRx);
				PJMEDIA_RTP_RD_EX_SET_PTT_ID(ext_val, stream->GRS_forced_ptt_id_value_in_RTPRx);
			}

			if (stream->GRS_force_SCT_in_RTPRx)
			{
				//Se pone a 1 el bit de mayor peso de los 3 bits RESERVED
				current_reserved = PJMEDIA_RTP_RD_EX_GET_RESERVED(ext_val);
				current_reserved |= 0x4;
				PJMEDIA_RTP_RD_EX_SET_RESERVED(ext_val, current_reserved);
			}

			if (stream->SelCalInProgress)
			{
				if (PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(ext_val) == RTP_PTT_OFF)
				{
					PJMEDIA_RTP_RD_EX_SET_PTT_TYPE(ext_val, RTP_PTT_NORMAL);
					PJMEDIA_RTP_RD_EX_SET_PTT_ID(ext_val, PJMEDIA_SELCAL_PTT_ID);
				}
				else
				{
					//Si hay otro PTT activo cancelamos el SELCAL
					stream->SelCalInProgress = PJ_FALSE;
				}
			}
		}

		if (stream->Force_PTTS_in_RTPTxRx)
		{			
			PJMEDIA_RTP_RD_EX_SET_PTTS(ext_val, 1);
		}

		status = pjmedia_rtp_encode_rtp(&stream->enc->rtp, 123, 0, 1, ts_len, (const void**)&rtphdr, &pkt_len);
		pj_assert(status == PJ_SUCCESS);

		stream->enc->rtp.out_hdr.x = 1;

		pj_memcpy(stream->enc->out_pkt, rtphdr, pkt_len);
		pj_memcpy((char*)stream->enc->out_pkt + pkt_len, &ext_hdr, sizeof(pj_uint32_t));

		if (req_MAM)
		{
			add_rmm_packet(stream, (char*)stream->enc->out_pkt + pkt_len + sizeof(ext_hdr), ext_val);
			pjmedia_transport_send_rtp(stream->transport, stream->enc->out_pkt, pkt_len + (3 * sizeof(pj_uint32_t)));
		}
		else if (send_MAM)
		{
			add_mam_packet(stream, (char*)stream->enc->out_pkt + pkt_len + sizeof(ext_hdr), ext_val, mam_T1, mam_T2, mam_Tj1, mam_Tid, mam_Ts2);
			if (stream->ED137version == 'C')
				pjmedia_transport_send_rtp(stream->transport, stream->enc->out_pkt, pkt_len + (6 * sizeof(pj_uint32_t)));
			else
				pjmedia_transport_send_rtp(stream->transport, stream->enc->out_pkt, pkt_len + (5 * sizeof(pj_uint32_t)));
		}		
		else
		{
			pj_memcpy((char*)stream->enc->out_pkt + pkt_len + sizeof(pj_uint32_t), &ext_val, sizeof(pj_uint32_t));

			pjmedia_transport_send_rtp(stream->transport, stream->enc->out_pkt, pkt_len + (2 * sizeof(pj_uint32_t)));	

			if (stream->radio_ua && PJMEDIA_RTP_RD_EX_GET_TYPE(stream->rtp_ext_tx_info) == 1)
			{
				//Si estamos enviando el qidx, porque somos un simulador de radio, entonces no borramos
				//la extension de cabecera
			}
			else
			{
				if (PJMEDIA_RTP_RD_EX_GET_X(ext_val))
				{
					//Si no es un request MAM y se ha enviado una extension de cabecera con TLV
					//Entonces borramos el TLV para que en el siguiente rtp no lo lleve
					PJMEDIA_RTP_RD_EX_SET_X(stream->rtp_ext_tx_info, 0);			
					PJMEDIA_RTP_RD_EX_SET_TYPE(stream->rtp_ext_tx_info, 0);
					PJMEDIA_RTP_RD_EX_SET_LENGTH(stream->rtp_ext_tx_info, 0);
					PJMEDIA_RTP_RD_EX_SET_CLD(stream->rtp_ext_tx_info, 0);
				}
			}
		}
				

		// Aunque en el ED 137 parte 1 se especifica que el keep-alive deber�a tener ts = 0 
		// creo que es m�s correcto no cambiar ts ni ssrc
		//((pjmedia_rtp_hdr*)stream->enc->out_pkt)->ts = 0;
		//((pjmedia_rtp_hdr*)stream->enc->out_pkt)->ssrc = 0x55555555;

		//pjmedia_transport_send_rtp(stream->transport, stream->enc->out_pkt, pkt_len + (2 * sizeof(pj_uint32_t)));

		//TRC_((stream->port.info.name.ptr, "Keep-alive sent (R2S RTP)"));
	}
	else if (stream->ka_type == PJMEDIA_STREAM_KA_EMPTY_RTP)
	{
		 /* Keep-alive packet is empty RTP */
		 pj_status_t status;
		 void *rtphdr;
		 int pkt_len;

		 status = pjmedia_rtp_encode_rtp( &stream->enc->rtp,
						  stream->enc->pt, 0,
						  1,
						  ts_len,
						  (const void**)&rtphdr,
						  &pkt_len);
		 pj_assert(status == PJ_SUCCESS);

		 pj_memcpy(stream->enc->out_pkt, rtphdr, pkt_len);
		 pjmedia_transport_send_rtp(stream->transport, stream->enc->out_pkt,
						 pkt_len);
		 TRC_((stream->port.info.name.ptr, "Keep-alive sent (empty RTP)"));
	}
	else if (stream->ka_type == PJMEDIA_STREAM_KA_USER)
	{
		 /* Keep-alive packet is defined in PJMEDIA_STREAM_KA_USER_PKT */
		 pj_ssize_t pkt_len;
		 const pj_str_t str_ka = PJMEDIA_STREAM_KA_USER_PKT;

		 pj_memcpy(stream->enc->out_pkt, str_ka.ptr, str_ka.slen);
		 pkt_len = str_ka.slen;
		 pjmedia_transport_send_rtp(stream->transport, stream->enc->out_pkt,
						 pkt_len);
		 TRC_((stream->port.info.name.ptr, "Keep-alive sent"));
	}

	stream->ka_forced = PJ_FALSE;		//Se se pone a false esta variable siempre que se envia un keep-alive
}

/*
 * play_callback()
 *
 * This callback is called by sound device's player thread when it
 * needs to feed the player with some frames.
 */
static pj_status_t get_frame( pjmedia_port *port, pjmedia_frame *frame)
{
    pjmedia_stream *stream = (pjmedia_stream*) port->port_data.pdata;
    pjmedia_channel *channel = stream->dec;
    unsigned samples_count, samples_per_frame, samples_required;
    pj_int16_t *p_out_samp;
    pj_status_t status;

    /* Return no frame is channel is paused */
    if (channel->paused) {
	frame->type = PJMEDIA_FRAME_TYPE_NONE;
	return PJ_SUCCESS;
    }

    /* Repeat get frame from the jitter buffer and decode the frame
     * until we have enough frames according to codec's ptime.
     */

    /* Lock jitter buffer mutex first */
    pj_mutex_lock( stream->jb_mutex );

    samples_required = stream->port.info.samples_per_frame;
    samples_per_frame = stream->codec_param.info.frm_ptime *
			stream->codec_param.info.clock_rate *
			stream->codec_param.info.channel_cnt / 
			1000;
    p_out_samp = (pj_int16_t*) frame->buf;

    for (samples_count=0; samples_count < samples_required; 
	 samples_count += samples_per_frame) 
    {
	char frame_type;
	pj_size_t frame_size = channel->out_pkt_size;
	pj_uint32_t bit_info;

	/* Get frame from jitter buffer. */
	pjmedia_jbuf_get_frame2(stream->jb, channel->out_pkt, &frame_size,
			        &frame_type, &bit_info);
	
	if (frame_type == PJMEDIA_JB_MISSING_FRAME) {
	    
	    /* Activate PLC */
	    if (stream->codec->op->recover && 
		stream->codec_param.setting.plc &&
		stream->plc_cnt < stream->max_plc_cnt) 
	    {
		pjmedia_frame frame_out;

		frame_out.buf = p_out_samp + samples_count;
		frame_out.size = frame->size - samples_count*2;
		status = (*stream->codec->op->recover)(stream->codec,
						       (unsigned int) frame_out.size,
						       &frame_out);

		++stream->plc_cnt;

	    } else {
		status = -1;
	    }

	    if (status != PJ_SUCCESS) {
		/* Either PLC failed or PLC not supported/enabled */
		pjmedia_zero_samples(p_out_samp + samples_count,
				     samples_required - samples_count);
	    }

	    if (frame_type != stream->jb_last_frm) {
		/* Report changing frame type event */
		PJ_LOG(5,(stream->port.info.name.ptr, "Frame lost%s!",
		          (status == PJ_SUCCESS? ", recovered":"")));

		stream->jb_last_frm = frame_type;
		stream->jb_last_frm_cnt = 1;
	    } else {
		stream->jb_last_frm_cnt++;
	    }

	} else if (frame_type == PJMEDIA_JB_ZERO_EMPTY_FRAME) {

	    const char *with_plc = "";

	    /* Jitter buffer is empty. If this is the first "empty" state,
	     * activate PLC to smoothen the fade-out, otherwise zero
	     * the frame. 
	     */
	    //Using this "if" will only invoke PLC for the first packet
	    //lost and not the subsequent ones.
	    //if (frame_type != stream->jb_last_frm) {
	    if (1) {
		/* Activate PLC to smoothen the missing frame */
		if (stream->codec->op->recover && 
		    stream->codec_param.setting.plc &&
		    stream->plc_cnt < stream->max_plc_cnt) 
		{
		    pjmedia_frame frame_out;

		    do {
			frame_out.buf = p_out_samp + samples_count;
			frame_out.size = frame->size - samples_count*2;
			status = (*stream->codec->op->recover)(stream->codec,
							       (unsigned)frame_out.size,
							       &frame_out);
			if (status != PJ_SUCCESS)
			    break;

			samples_count += samples_per_frame;
			++stream->plc_cnt;

		    } while (samples_count < samples_required &&
			     stream->plc_cnt < stream->max_plc_cnt);

		    with_plc = ", plc invoked";
		} 
	    }

	    if (samples_count < samples_required) {
		pjmedia_zero_samples(p_out_samp + samples_count,
				     samples_required - samples_count);
		samples_count = samples_required;
	    }

	    if (stream->jb_last_frm != frame_type) {
		pjmedia_jb_state jb_state;

		/* Report changing frame type event */
		pjmedia_jbuf_get_state(stream->jb, &jb_state);
		PJ_LOG(5,(stream->port.info.name.ptr, 
			  "Jitter buffer empty (prefetch=%d)%s", 
			  jb_state.prefetch, with_plc));

		stream->jb_last_frm = frame_type;
		stream->jb_last_frm_cnt = 1;
	    } else {
		stream->jb_last_frm_cnt++;
	    }
	    break;

	} else if (frame_type != PJMEDIA_JB_NORMAL_FRAME) {

	    const char *with_plc = "";

	    /* It can only be PJMEDIA_JB_ZERO_PREFETCH frame */
	    pj_assert(frame_type == PJMEDIA_JB_ZERO_PREFETCH_FRAME);

	    /* Always activate PLC when it's available.. */
	    if (stream->codec->op->recover && 
		stream->codec_param.setting.plc &&
		stream->plc_cnt < stream->max_plc_cnt) 
	    {
		pjmedia_frame frame_out;

		do {
		    frame_out.buf = p_out_samp + samples_count;
		    frame_out.size = frame->size - samples_count*2;
		    status = (*stream->codec->op->recover)(stream->codec,
							   (unsigned)frame_out.size,
							   &frame_out);
		    if (status != PJ_SUCCESS)
			break;
		    samples_count += samples_per_frame;

		    ++stream->plc_cnt;

		} while (samples_count < samples_required &&
			 stream->plc_cnt < stream->max_plc_cnt);

		with_plc = ", plc invoked";
	    } 

	    if (samples_count < samples_required) {
		pjmedia_zero_samples(p_out_samp + samples_count,
				     samples_required - samples_count);
		samples_count = samples_required;
	    }

	    if (stream->jb_last_frm != frame_type) {
		pjmedia_jb_state jb_state;

		/* Report changing frame type event */
		pjmedia_jbuf_get_state(stream->jb, &jb_state);
		PJ_LOG(5,(stream->port.info.name.ptr, 
			  "Jitter buffer is bufferring (prefetch=%d)%s", 
			  jb_state.prefetch, with_plc));

		stream->jb_last_frm = frame_type;
		stream->jb_last_frm_cnt = 1;
	    } else {
		stream->jb_last_frm_cnt++;
	    }
	    break;

	} else {
	    /* Got "NORMAL" frame from jitter buffer */
	    pjmedia_frame frame_in, frame_out;

	    stream->plc_cnt = 0;

	    /* Decode */
	    frame_in.buf = channel->out_pkt;
	    frame_in.size = frame_size;
	    frame_in.bit_info = bit_info;
	    frame_in.type = PJMEDIA_FRAME_TYPE_AUDIO;  /* ignored */

	    frame_out.buf = p_out_samp + samples_count;
	    frame_out.size = frame->size - samples_count*BYTES_PER_SAMPLE;
	    status = stream->codec->op->decode( stream->codec, &frame_in,
						(unsigned) frame_out.size, PJ_TRUE, &frame_out);
	    if (status != 0) {
		LOGERR_((port->info.name.ptr, "codec decode() error", 
			 status));

		pjmedia_zero_samples(p_out_samp + samples_count, 
				     samples_per_frame);
	    }

	    if (stream->jb_last_frm != frame_type) {
		/* Report changing frame type event */
		PJ_LOG(5,(stream->port.info.name.ptr, 
			  "Jitter buffer starts returning normal frames "
			  "(after %d empty/lost)",
			  stream->jb_last_frm_cnt, stream->jb_last_frm));

		stream->jb_last_frm = frame_type;
		stream->jb_last_frm_cnt = 1;
	    } else {
		stream->jb_last_frm_cnt++;
	    }
	}
    }


    /* Unlock jitter buffer mutex. */
    pj_mutex_unlock( stream->jb_mutex );

    /* Return PJMEDIA_FRAME_TYPE_NONE if we have no frames at all
     * (it can happen when jitter buffer returns PJMEDIA_JB_ZERO_EMPTY_FRAME).
     */
    if (samples_count == 0) {
	frame->type = PJMEDIA_FRAME_TYPE_NONE;
	frame->size = 0;
    } else {
	frame->type = PJMEDIA_FRAME_TYPE_AUDIO;
	frame->size = samples_count * BYTES_PER_SAMPLE;
	frame->timestamp.u64 = 0;

	if (stream->p_echo)
	{
		pj_lock_acquire(stream->p_echo_lock);
		pjmedia_echo_capture(stream->p_echo, (pj_int16_t *) frame->buf, 0);
		pj_lock_release(stream->p_echo_lock);
	}
    }

    return PJ_SUCCESS;
}


/* The other version of get_frame callback used when stream port format
 * is non linear PCM.
 */
static pj_status_t get_frame_ext( pjmedia_port *port, pjmedia_frame *frame)
{
    pjmedia_stream *stream = (pjmedia_stream*) port->port_data.pdata;
    pjmedia_channel *channel = stream->dec;
    pjmedia_frame_ext *f = (pjmedia_frame_ext*)frame;
    unsigned samples_per_frame, samples_required;
    pj_status_t status;

    /* Return no frame if channel is paused */
    if (channel->paused) {
	frame->type = PJMEDIA_FRAME_TYPE_NONE;
	return PJ_SUCCESS;
    }

    /* Repeat get frame from the jitter buffer and decode the frame
     * until we have enough frames according to codec's ptime.
     */

    samples_required = stream->port.info.samples_per_frame;
    samples_per_frame = stream->codec_param.info.frm_ptime *
			stream->codec_param.info.clock_rate *
			stream->codec_param.info.channel_cnt / 
			1000;

    pj_bzero(f, sizeof(pjmedia_frame_ext));
    f->base.type = PJMEDIA_FRAME_TYPE_EXTENDED;

    while (f->samples_cnt < samples_required) {
	char frame_type;
	pj_size_t frame_size = channel->out_pkt_size;
	pj_uint32_t bit_info;

	/* Lock jitter buffer mutex first */
	pj_mutex_lock( stream->jb_mutex );

	/* Get frame from jitter buffer. */
	pjmedia_jbuf_get_frame2(stream->jb, channel->out_pkt, &frame_size,
			        &frame_type, &bit_info);
	
	/* Unlock jitter buffer mutex. */
	pj_mutex_unlock( stream->jb_mutex );

	if (frame_type == PJMEDIA_JB_NORMAL_FRAME) {
	    /* Got "NORMAL" frame from jitter buffer */
	    pjmedia_frame frame_in;

	    /* Decode */
	    frame_in.buf = channel->out_pkt;
	    frame_in.size = frame_size;
	    frame_in.bit_info = bit_info;
	    frame_in.type = PJMEDIA_FRAME_TYPE_AUDIO;

	    status = stream->codec->op->decode( stream->codec, &frame_in,
						0, PJ_TRUE, frame);
	    if (status != PJ_SUCCESS) {
		LOGERR_((port->info.name.ptr, "codec decode() error", 
			 status));
		pjmedia_frame_ext_append_subframe(f, NULL, 0,
					    (pj_uint16_t)samples_per_frame);
	    }
	    if (stream->jb_last_frm != frame_type) {
		/* Report changing frame type event */
		PJ_LOG(5,(stream->port.info.name.ptr, 
			  "Jitter buffer starts returning normal frames "
			  "(after %d empty/lost)",
			  stream->jb_last_frm_cnt, stream->jb_last_frm));

		stream->jb_last_frm = frame_type;
		stream->jb_last_frm_cnt = 1;
	    } else {
		stream->jb_last_frm_cnt++;
	    }

	} else {

	    /* Try to generate frame by invoking PLC (when any) */
	    status = PJ_SUCCESS;
	    if (stream->codec->op->recover) {
		status = (*stream->codec->op->recover)(stream->codec,
						       0, frame);
	    }
	    
	    /* No PLC or PLC failed */
	    if (!stream->codec->op->recover || status != PJ_SUCCESS) {
		pjmedia_frame_ext_append_subframe(f, NULL, 0,
					    (pj_uint16_t)samples_per_frame);
	    }

	    if (frame_type == PJMEDIA_JB_MISSING_FRAME) {
		if (frame_type != stream->jb_last_frm) {
		    /* Report changing frame type event */
		    PJ_LOG(5,(stream->port.info.name.ptr, "Frame lost!"));

		    stream->jb_last_frm = frame_type;
		    stream->jb_last_frm_cnt = 1;
		} else {
		    stream->jb_last_frm_cnt++;
		}
	    } else if (frame_type == PJMEDIA_JB_ZERO_EMPTY_FRAME) {
		if (frame_type != stream->jb_last_frm) {
		    pjmedia_jb_state jb_state;

		    /* Report the state of jitter buffer */
		    pjmedia_jbuf_get_state(stream->jb, &jb_state);
		    PJ_LOG(5,(stream->port.info.name.ptr, 
			      "Jitter buffer empty (prefetch=%d)", 
			      jb_state.prefetch));

		    stream->jb_last_frm = frame_type;
		    stream->jb_last_frm_cnt = 1;
		} else {
		    stream->jb_last_frm_cnt++;
		}
	    } else {

		/* It can only be PJMEDIA_JB_ZERO_PREFETCH frame */
		pj_assert(frame_type == PJMEDIA_JB_ZERO_PREFETCH_FRAME);

		if (stream->jb_last_frm != frame_type) {
		    pjmedia_jb_state jb_state;

		    /* Report changing frame type event */
		    pjmedia_jbuf_get_state(stream->jb, &jb_state);
		    PJ_LOG(5,(stream->port.info.name.ptr, 
			      "Jitter buffer is bufferring (prefetch=%d)",
			      jb_state.prefetch));

		    stream->jb_last_frm = frame_type;
		    stream->jb_last_frm_cnt = 1;
		} else {
		    stream->jb_last_frm_cnt++;
		}
	    }
	}
    }

    return PJ_SUCCESS;
}


/*
 * Transmit DTMF
 */
static void create_dtmf_payload(pjmedia_stream *stream, 
			        struct pjmedia_frame *frame_out,
				int *first, int *last)
{
    pjmedia_rtp_dtmf_event *event;
    struct dtmf *digit = &stream->tx_dtmf_buf[0];
    pj_uint32_t cur_ts;

    pj_assert(sizeof(pjmedia_rtp_dtmf_event) == 4);

    *first = *last = 0;

    event = (pjmedia_rtp_dtmf_event*) frame_out->buf;
    cur_ts = pj_ntohl(stream->enc->rtp.out_hdr.ts);

    if (digit->duration == 0) {
	PJ_LOG(5,(stream->port.info.name.ptr, "Sending DTMF digit id %c", 
		  digitmap[digit->event]));
	*first = 1;
    }

    digit->duration += stream->port.info.samples_per_frame;

    event->event = (pj_uint8_t)digit->event;
    event->e_vol = 10;
    event->duration = pj_htons((pj_uint16_t)digit->duration);


    if (digit->duration >= PJMEDIA_DTMF_DURATION) {

	event->e_vol |= 0x80;
	*last = 1;

	/* Prepare next digit. */
	pj_mutex_lock(stream->jb_mutex);

	pj_array_erase(stream->tx_dtmf_buf, sizeof(stream->tx_dtmf_buf[0]),
		       stream->tx_dtmf_count, 0);
	--stream->tx_dtmf_count;

	pj_mutex_unlock(stream->jb_mutex);
    }

    frame_out->size = 4;
}


/**
 * check_tx_rtcp()
 *
 * This function is can be called by either put_frame() or get_frame(),
 * to transmit periodic RTCP SR/RR report.
 */
static void check_tx_rtcp(pjmedia_stream *stream, pj_uint32_t timestamp)
{
    /* Note that timestamp may represent local or remote timestamp, 
     * depending on whether this function is called from put_frame()
     * or get_frame().
     */


    if (stream->rtcp_last_tx == 0) {
	
	stream->rtcp_last_tx = timestamp;

    } else if (timestamp - stream->rtcp_last_tx >= stream->rtcp_interval) {
	
	void *rtcp_pkt;
	int len;

	pjmedia_rtcp_build_rtcp(&stream->rtcp, &rtcp_pkt, &len);

	pjmedia_transport_send_rtcp(stream->transport, rtcp_pkt, len);

	stream->rtcp_last_tx = timestamp;
    }

#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)
    if (stream->rtcp.xr_enabled) {

	if (stream->rtcp_xr_last_tx == 0) {
    	
	    stream->rtcp_xr_last_tx = timestamp;

	} else if (timestamp - stream->rtcp_xr_last_tx >= 
		   stream->rtcp_xr_interval)
	{
	    int i;
	    pjmedia_jb_state jb_state;
	    void *rtcp_pkt;
	    int len;

	    /* Update RTCP XR with current JB states */
	    pjmedia_jbuf_get_state(stream->jb, &jb_state);
    	    
	    i = jb_state.avg_delay;
	    pjmedia_rtcp_xr_update_info(&stream->rtcp.xr_session, 
					PJMEDIA_RTCP_XR_INFO_JB_NOM,
					i);

	    i = jb_state.max_delay;
	    pjmedia_rtcp_xr_update_info(&stream->rtcp.xr_session, 
					PJMEDIA_RTCP_XR_INFO_JB_MAX,
					i);

	    /* Build RTCP XR packet */
	    pjmedia_rtcp_build_rtcp_xr(&stream->rtcp.xr_session, 0, 
				       &rtcp_pkt, &len);

	    /* Send the RTCP XR to remote address */
	    pjmedia_transport_send_rtcp(stream->transport, rtcp_pkt, len);

	    /* Send the RTCP XR to third-party destination if specified */
	    if (stream->rtcp_xr_dest_len) {
		pjmedia_transport_send_rtcp2(stream->transport, 
					     &stream->rtcp_xr_dest,
					     stream->rtcp_xr_dest_len, 
					     rtcp_pkt, len);
	    }

	    /* Update last tx RTCP XR */
	    stream->rtcp_xr_last_tx = timestamp;
	}
    }
#endif
}

/* Build RTCP SDES packet */
static unsigned create_rtcp_sdes(pjmedia_stream *stream, pj_uint8_t *pkt,
				 unsigned max_len)
{
    pjmedia_rtcp_common hdr;
    pj_uint8_t *p = pkt;

    /* SDES header */
    hdr.version = 2;
    hdr.p = 0;
    hdr.count = 1;
    hdr.pt = 202;
    hdr.length = 2 + (4+((unsigned)stream->cname.slen)+3)/4 - 1;
    if (max_len < (hdr.length << 2)) {
	pj_assert(!"Not enough buffer for SDES packet");
	return 0;
    }
    hdr.length = pj_htons((pj_uint16_t)hdr.length);
    hdr.ssrc = stream->enc->rtp.out_hdr.ssrc;
    pj_memcpy(p, &hdr, sizeof(hdr));
    p += sizeof(hdr);

    /* CNAME item */
    *p++ = 1;
    *p++ = (pj_uint8_t)stream->cname.slen;
    pj_memcpy(p, stream->cname.ptr, stream->cname.slen);
    p += stream->cname.slen;

    /* END */
    *p++ = '\0';
    *p++ = '\0';

    /* Pad to 32bit */
    while ((p-pkt) % 4)
	*p++ = '\0';

    return (unsigned)(p - pkt);
}

/* Build RTCP BYE packet */
static unsigned create_rtcp_bye(pjmedia_stream *stream, pj_uint8_t *pkt,
				unsigned max_len)
{
    pjmedia_rtcp_common hdr;

    /* BYE header */
    hdr.version = 2;
    hdr.p = 0;
    hdr.count = 1;
    hdr.pt = 203;
    hdr.length = 1;
    if (max_len < (hdr.length << 2)) {
	pj_assert(!"Not enough buffer for SDES packet");
	return 0;
    }
    hdr.length = pj_htons((pj_uint16_t)hdr.length);
    hdr.ssrc = stream->enc->rtp.out_hdr.ssrc;
    pj_memcpy(pkt, &hdr, sizeof(hdr));

    return sizeof(hdr);
}


/**
 * Rebuffer the frame when encoder and decoder has different ptime
 * (such as when different iLBC modes are used by local and remote)
 */
static void rebuffer(pjmedia_stream *stream,
		     pjmedia_frame *frame)
{
    /* How many samples are needed */
    unsigned count;

    /* Normalize frame */
    if (frame->type != PJMEDIA_FRAME_TYPE_AUDIO)
	frame->size = 0;

    /* Remove used frame from the buffer. */
    if (stream->enc_buf_pos) {
	if (stream->enc_buf_count) {
	    pj_memmove(stream->enc_buf,
		       stream->enc_buf + stream->enc_buf_pos,
		       (stream->enc_buf_count << 1));
	}
	stream->enc_buf_pos = 0;
    }

    /* Make sure we have space to store the new frame */
    pj_assert(stream->enc_buf_count + (frame->size >> 1) <
		stream->enc_buf_size);

    /* Append new frame to the buffer */
    if (frame->size) {
	/* Handle case when there is no port transmitting to this port */
	if (frame->buf) {
	    pj_memcpy(stream->enc_buf + stream->enc_buf_count,
		      frame->buf, frame->size);
	} else {
	    pj_bzero(stream->enc_buf + stream->enc_buf_count, frame->size);
	}
	stream->enc_buf_count += ((unsigned)frame->size >> 1);
    }

    /* How many samples are needed */
    count = stream->codec_param.info.enc_ptime * 
		stream->port.info.clock_rate / 1000;

    /* See if we have enough samples */
    if (stream->enc_buf_count >= count) {

	frame->type = PJMEDIA_FRAME_TYPE_AUDIO;
	frame->buf = stream->enc_buf;
	frame->size = (count << 1);

	stream->enc_buf_pos = count;
	stream->enc_buf_count -= count;

    } else {
	/* We don't have enough samples */
	frame->type = PJMEDIA_FRAME_TYPE_NONE;
    }
}

static void timer_entry_latency_cb(pj_timer_heap_t* th, pj_timer_entry* te)
{
	PJ_UNUSED_ARG(th);
	pjmedia_stream* stream;
	MYDATA* pMyData = (MYDATA*)te->user_data;

	if (pMyData == NULL) return;
	stream = (pjmedia_stream*)pMyData->stream;
	te->user_data = NULL;

	if (stream && stream->transport) {	//Comprobamos que siga la comunicación abierta
		pj_thread_desc desc;
		pj_thread_t* th = NULL;
		if (!pj_thread_is_registered())
		{
			pj_thread_register(NULL, desc, &th);
		}
		pjmedia_transport_send_rtp(stream->transport, pMyData->pkt, pMyData->size);
		if (th != NULL) pj_thread_unregister();
	}
	free(pMyData);
}

/**
 * put_frame_imp()
 */
static pj_status_t put_frame_imp( pjmedia_port *port, const pjmedia_frame *frame )
{
    pjmedia_stream *stream = (pjmedia_stream*) port->port_data.pdata;
    pjmedia_channel *channel = stream->enc;
    pj_status_t status = 0;
    pjmedia_frame frame_out;
    unsigned ts_len, rtp_ts_len, samples_per_frame;
    void *rtphdr;
    int rtphdrlen;
    int inc_timestamp = 0;
	int ka_ts_len = 0;
	unsigned rtp_hdr_size = sizeof(pjmedia_rtp_hdr) + (stream->rtp_ext_enabled ? 2 * sizeof(pj_uint32_t) : 0);
	pj_bool_t req_MAM = stream->request_MAM;
	pj_uint32_t mam_T1 = 0;
	pj_uint32_t mam_T2 = 0;
	pj_uint16_t mam_Tj1 = 0;
	pj_uint16_t mam_Tid = 0;
	pj_uint16_t mam_Ts2 = 0;
	pj_bool_t send_MAM = PJ_FALSE;
	pj_bool_t enviar_paquete_rtp_por_impairement = PJ_TRUE;
	pj_bool_t keep_alive_enviado_en_este_frame = PJ_FALSE;		//Si se ha enviado un keep alive en este mismo frame
	pj_uint32_t current_reserved;
	pj_bool_t force_header_extension = PJ_FALSE;				//Fuerza extension de cabecera aunque no sea llamada de radio
	pj_bool_t audio_not_sent = PJ_FALSE;

	if (stream->force_no_send_rtp)
	{
		stream->enc_buf_pos = stream->enc_buf_count = 0;
		return PJ_SUCCESS;
	}

	/* If the interval since last sending packet is greater than
	 * ka_local_interval, send keep-alive packet.
	 */
	if (stream->ka_type != 0)
	{
		pj_uint32_t dtx_duration;

		if (stream->ka_received)
		{
			stream->ka_received = PJ_FALSE;
			stream->last_vf_ts_received = frame->timestamp;
		}
		else if (stream->last_vf_ts_received.u64 == 0)
		{
			stream->last_vf_ts_received = frame->timestamp;
		}
		else
		{
			dtx_duration = pj_timestamp_diff32(&stream->last_vf_ts_received, &frame->timestamp);
			if (dtx_duration > (stream->ka_remote_timeout * stream->port.info.clock_rate) / 1000)
			{
				if (pj_app_cbs.on_stream_ka_timeout)
					pj_app_cbs.on_stream_ka_timeout(stream);
				stream->last_vf_ts_received = frame->timestamp;
			}
		}

		if (channel->paused) {

			//No enviamos el keep-alive pero si testeamos el keep-alive time out

			stream->enc_buf_pos = stream->enc_buf_count = 0;
			return PJ_SUCCESS;
		}

		dtx_duration = pj_timestamp_diff32(&stream->last_frm_ts_sent, &frame->timestamp);

		if ((dtx_duration >= (stream->ka_local_interval * stream->port.info.clock_rate) / 1000)
			||
			(stream->ka_forced))
		{
			ka_ts_len = (int)dtx_duration;
			if (ka_ts_len < 0) ka_ts_len = 0;
			send_keep_alive_packet(stream, ka_ts_len);
			stream->last_frm_ts_sent = frame->timestamp;
			keep_alive_enviado_en_este_frame = PJ_TRUE;
			stream->ka_send = PJ_TRUE;
		}
	}

	 /* Don't do anything if stream is paused */
	/*
	if (channel->paused ||
		 (stream->rtp_ext_enabled && (PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(stream->rtp_ext_tx_info) == 0))) {
	stream->enc_buf_pos = stream->enc_buf_count = 0;
	return PJ_SUCCESS;
	}
	*/

	if (channel->paused) {
		stream->enc_buf_pos = stream->enc_buf_count = 0;
		return PJ_SUCCESS;
	}

	if (stream->radio_ua)
	{
		//Si el recurso es tx only o idle. No se envia RTP independientemente del tipo de SQU
		if ((stream->audio_flags & STREAM_TXONLY) || (stream->audio_flags & STREAM_IDLE))
		{
			stream->enc_buf_pos = stream->enc_buf_count = 0;
			audio_not_sent = PJ_TRUE;
		}
		else if (stream->rtp_ext_enabled && (PJMEDIA_RTP_RD_EX_GET_SQU(stream->rtp_ext_tx_info) == 0))
		{
			if (stream->SQU_rep_count == 0)
			{
				stream->enc_buf_pos = stream->enc_buf_count = 0;
				audio_not_sent = PJ_TRUE;
			}
			else
			{
				stream->SQU_rep_count -= 1;
			}
		}
	}
	else
	{
		//Si el recurso es rx only o idle. No se envia RTP independientemente del tipo de PTT
		if ((stream->audio_flags & STREAM_RXONLY) || (stream->audio_flags & STREAM_IDLE)) 
		{
			stream->enc_buf_pos = stream->enc_buf_count = 0;
			audio_not_sent = PJ_TRUE;
		}
		else if (stream->rtp_ext_enabled && (PJMEDIA_RTP_RD_EX_GET_PM(stream->rtp_ext_tx_info) == 1))
		{
			//Si Ptt Mute esta activado entonces no enviamos audio a la radio
			stream->enc_buf_pos = stream->enc_buf_count = 0;
			audio_not_sent = PJ_TRUE;
		}
		else if (stream->rtp_ext_enabled && (PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(stream->rtp_ext_tx_info) == 0))
		{
			if (stream->PTT_rep_count == 0)
			{
				stream->enc_buf_pos = stream->enc_buf_count = 0;
				audio_not_sent = PJ_TRUE;
			}
			else
			{
				stream->PTT_rep_count -= 1;
			}
		}
	}

	if (audio_not_sent == PJ_FALSE && (stream->radio_ua && stream->GRS_force_ptt_in_RTPRx_confirmed))
	{
		pj_uint32_t current_squ;
		pj_uint32_t current_ptt_id;
		current_squ = PJMEDIA_RTP_RD_EX_GET_SQU(stream->rtp_ext_tx_info);
		current_ptt_id = PJMEDIA_RTP_RD_EX_GET_PTT_ID(stream->rtp_ext_tx_info);
		if (current_squ != 0 &&
			 current_ptt_id == 0)
		{
			 //Si es squelch de avion, entonces lo enviamos
		}
		else
		{
			audio_not_sent = PJ_TRUE;
		}
	}

	if (audio_not_sent)
	{
		//No se envia audio. Se chequea si se fuerza keepalive para enviar RMM, MAM ...
		if (stream->request_MAM || stream->send_MAM)
		{
			pj_uint32_t dtx_duration;
			dtx_duration = pj_timestamp_diff32(&stream->last_frm_ts_sent, &frame->timestamp);

			ka_ts_len = (int)dtx_duration;
			if (ka_ts_len < 0) ka_ts_len = 0;
			send_keep_alive_packet(stream, ka_ts_len);
			stream->last_frm_ts_sent = frame->timestamp;
			stream->ka_send = PJ_TRUE;
		}
		return PJ_SUCCESS;
	}

	 /* Number of samples in the frame */
	 if (keep_alive_enviado_en_este_frame)
	 {
		 ts_len = 0;		//Si en este mismo frame se ha enviado un keepalive, el cual ya ha incrementado el time-stamp 
							//Entonces el paquete rtp que se ha a enviar no lo incrementa
	 }
	 else if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO)
	 {
		 if (stream->ka_send == PJ_TRUE)
		 {
			 //Se va a enviar un rtp despues de un keep-alive, posiblemente porque se ha activado el PTT o SQU
			 //En este caso se incrementa el timestamp de acuerdo al tiempo transcurrido
			 pj_uint32_t dtx_duration;
			 dtx_duration = pj_timestamp_diff32(&stream->last_frm_ts_sent, &frame->timestamp);
			 ts_len = (int)dtx_duration;
			 if (ts_len < 0) ts_len = 0;
		 }
		 else
		 {
			 ts_len = ((unsigned)frame->size >> 1) / stream->codec_param.info.channel_cnt;
		 }		 
	 }
	 else if (frame->type == PJMEDIA_FRAME_TYPE_EXTENDED)
		 ts_len = stream->port.info.samples_per_frame / 
		 stream->port.info.channel_count;
	 else
		 ts_len = 0;

	 stream->ka_send = PJ_FALSE;

	 //Se suma a la longitud de la extensión de cabecera la de los TLV. El RMM y MAM lo permitimos cuando no es llamada de radio
	 if (req_MAM)
	 {
		 rtp_hdr_size += sizeof(pj_uint32_t);		//El RMM necesita una palabra mas de 32 bits. 
													//Son 3 bytes. Uno va en la misma palabra que la señalizacion (PTT, SQU, etc) y los otros dos en la siguiente palabra.
		 if (!stream->rtp_ext_enabled)
		 {
			 rtp_hdr_size += 2 * sizeof(pj_uint32_t);	//Si no es una llamada de radio, y se envia RMM, seguramente porque es un simulador VCS de ETM
														//entonces se agrega una extension de cabecera simulada con info de PTT, SQU, etc. 
			 force_header_extension = PJ_TRUE;
		 }
	 }
	 else
	 {
		 //Si se va a enviar el RMM, entonces nos esperamos a enviar el MAM en el siguiente paquete

		 pj_mutex_lock(stream->mam_mutex);
		 mam_T1 = stream->mam_T1;
		 mam_T2 = stream->mam_T2;
		 mam_Tj1 = stream->mam_Tj1;
		 mam_Tid = stream->mam_Tid;
		 mam_Ts2 = stream->mam_Ts2;
		 send_MAM = stream->send_MAM;
		 stream->send_MAM = PJ_FALSE;
		 pj_mutex_unlock(stream->mam_mutex);

		 if (send_MAM)
		 {
			 if (stream->ED137version == 'C')
			 {
				 //ED137C
				 rtp_hdr_size += sizeof(pj_uint32_t) * 4;	//El MAM necesita 4 palabras mas de 32 bits.
															//Son 14 bytes:
															//Uno va en la misma palabra que la señalizacion (PTT, SQU, etc)
															//Los 13 bytes que restan necesitan 4 palabras mas de 32 bits
			 }
			 else
			 {
				 //ED137B
				 rtp_hdr_size += sizeof(pj_uint32_t) * 3;	//El MAM necesita 3 palabras mas de 32 bits.
															//Son 12 bytes:
															//Uno va en la misma palabra que la señalizacion (PTT, SQU, etc)
															//Los 11 bytes que restan necesitan 3 palabras más de 32 bits
			 }
			 if (!stream->rtp_ext_enabled)
			 {
				 rtp_hdr_size += 2 * sizeof(pj_uint32_t);	//Si no es una llamada de radio, y se envia MAM, seguramente porque es un simulador GRS de ETM,
															//entonces se agrega una extension de cabecera con info de PTT, SQU, etc simulada
				 force_header_extension = PJ_TRUE;
			 }
		 }
	 }

#if defined(PJMEDIA_HANDLE_G722_MPEG_BUG) && (PJMEDIA_HANDLE_G722_MPEG_BUG!=0)
	 /* Handle special case for audio codec with RTP timestamp inconsistence 
	 * e.g: G722, MPEG audio.
	 */
	 if (stream->has_g722_mpeg_bug)
		 rtp_ts_len = stream->rtp_tx_ts_len_per_pkt;
	 else
		 rtp_ts_len = ts_len;
#else
	 rtp_ts_len = ts_len;
#endif

	 /* Increment transmit duration */
	 stream->tx_duration += ts_len;

    /* Init frame_out buffer. */
	frame_out.buf = ((char*)channel->out_pkt) + rtp_hdr_size;
    frame_out.size = 0;

    /* Calculate number of samples per frame */
    samples_per_frame = stream->enc_samples_per_pkt;


    /* If we have DTMF digits in the queue, transmit the digits. 
     * Otherwise encode the PCM buffer.
     */
    if (stream->tx_dtmf_count) {
	int first=0, last=0;

	create_dtmf_payload(stream, &frame_out, &first, &last);

	/* Encapsulate into RTP packet. Note that:
         *  - RTP marker should be set on the beginning of a new event
	 *  - RTP timestamp is constant for the same packet. 
         */
	status = pjmedia_rtp_encode_rtp( &channel->rtp, 
					 stream->tx_event_pt, first, 
					 (int)frame_out.size,
					 (first ? rtp_ts_len : 0), 
					 (const void**)&rtphdr, 
					 &rtphdrlen);

	if (last) {
	    /* This is the last packet for the event. 
	     * Increment the RTP timestamp of the RTP session, for next
	     * RTP packets.
	     */
	    inc_timestamp = PJMEDIA_DTMF_DURATION - rtp_ts_len;
	}


    /*
     * Special treatment for FRAME_TYPE_AUDIO but with frame->buf==NULL.
     * This happens when stream input is disconnected from the bridge.
     * In this case we periodically transmit RTP frame to keep NAT binding
     * open, by giving zero PCM frame to the codec.
     *
     * This was originally done in http://trac.pjsip.org/repos/ticket/56,
     * but then disabled in http://trac.pjsip.org/repos/ticket/439, but
     * now it's enabled again.
     */
    } else if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO &&
	       frame->buf == NULL &&
	       stream->port.info.format.id == PJMEDIA_FORMAT_L16 &&
	       (stream->dir & PJMEDIA_DIR_ENCODING) &&
			 frame->size
	       /* stream->codec_param.info.frm_ptime *
	       stream->codec_param.info.channel_cnt *
	       stream->codec_param.info.clock_rate/1000 */ <
		  PJ_ARRAY_SIZE(zero_frame)) 
    {
	pjmedia_frame silence_frame;

	pj_bzero(&silence_frame, sizeof(silence_frame));
	silence_frame.buf = zero_frame;
	silence_frame.size = frame->size;
	/* silence_frame.size = stream->codec_param.info.frm_ptime * 2 *
			     stream->codec_param.info.channel_cnt *
			     stream->codec_param.info.clock_rate / 1000; */
	silence_frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
	silence_frame.timestamp.u32.lo = pj_ntohl(stream->enc->rtp.out_hdr.ts);
	
	if (stream->p_echo)
	{
		pj_lock_acquire(stream->p_echo_lock);
		pjmedia_echo_playback(stream->p_echo, zero_frame);
		pj_lock_release(stream->p_echo_lock);
	}

	/* Encode! */
	status = stream->codec->op->encode( stream->codec, &silence_frame,
			channel->out_pkt_size - rtp_hdr_size,
			&frame_out);
	if (status != PJ_SUCCESS) {
	    LOGERR_((stream->port.info.name.ptr, 
		    "Codec encode() error", status));
	    return status;
	}

	/* Encapsulate. */
	status = pjmedia_rtp_encode_rtp( &channel->rtp, 
					 channel->pt, 0, 
					 (int)frame_out.size, rtp_ts_len, 
					 (const void**)&rtphdr, 
					 &rtphdrlen);


    /* Encode audio frame */
    } else if ((frame->type == PJMEDIA_FRAME_TYPE_AUDIO &&
	        frame->buf != NULL) ||
	       (frame->type == PJMEDIA_FRAME_TYPE_EXTENDED))
    {
		 if (stream->p_echo)
		 {
			 pj_lock_acquire(stream->p_echo_lock);
			 pjmedia_echo_playback(stream->p_echo, (pj_int16_t *) frame->buf);
			 pj_lock_release(stream->p_echo_lock);
		 }

	/* Encode! */
	status = stream->codec->op->encode( stream->codec, frame, 
			channel->out_pkt_size - rtp_hdr_size,
			&frame_out);
	if (status != PJ_SUCCESS) {
	    LOGERR_((stream->port.info.name.ptr, 
		    "Codec encode() error", status));
	    return status;
	}

	/* Encapsulate. */
	status = pjmedia_rtp_encode_rtp( &channel->rtp, 
					 channel->pt, 0, 
					 (int)frame_out.size, rtp_ts_len, 
					 (const void**)&rtphdr, 
					 &rtphdrlen);

    } else {

	/* Just update RTP session's timestamp. */
	status = pjmedia_rtp_encode_rtp( &channel->rtp, 
					 0, 0, 
					 0, rtp_ts_len, 
					 (const void**)&rtphdr, 
					 &rtphdrlen);

    }

    if (status != PJ_SUCCESS) {
	LOGERR_((stream->port.info.name.ptr, 
		"RTP encode_rtp() error", status));
	return status;
    }

    /* Check if now is the time to transmit RTCP SR/RR report. 
     * We only do this when stream direction is not "decoding only", because
     * when it is, check_tx_rtcp() will be handled by get_frame().
     */
    if (stream->dir != PJMEDIA_DIR_DECODING) {
	check_tx_rtcp(stream, pj_ntohl(channel->rtp.out_hdr.ts));
    }

    /* Do nothing if we have nothing to transmit */
    if (frame_out.size == 0) {
	if (stream->is_streaming) {
	    PJ_LOG(5,(stream->port.info.name.ptr,"Starting silence"));
	    stream->is_streaming = PJ_FALSE;
	}

	return PJ_SUCCESS;
    }

	 if (stream->rtp_ext_enabled || force_header_extension)
	 { 
		 /** AGL 140528. Cabercera para ED137A */
		 pj_uint32_t ex_hdr = 0x01006701;		// 0x01006700;
		 pj_uint32_t ex_val;
		 if (stream->rtp_ext_enabled) ex_val = stream->rtp_ext_tx_info;
		 else ex_val = 0;

		 if (stream->radio_ua && PJMEDIA_RTP_RD_EX_GET_SQU(stream->rtp_ext_tx_info) != 0)
		 {
			 //Es un agente radio con squelch activado. 
			 stream->SQU_rep_count = (pj_uint32_t) PTT_REP_COUNT;
		 }
		 else if (!stream->radio_ua && PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(stream->rtp_ext_tx_info) != 0)
		 {
			 //No es un agente radio y el PTT esta activo
			 stream->PTT_rep_count = (pj_uint32_t) PTT_REP_COUNT;
		 }
		 
		 if ((stream->radio_ua) && (PJMEDIA_RTP_RD_EX_GET_PTT_ID(stream->rtp_ext_tx_info) == 0))
		 {
			//Somos un agente radio. Si el PTT id es cero, entonces sera una llamada desde el avion
			//En ese caso el PTT-ID sera cero
			PJMEDIA_RTP_RD_EX_SET_PTT_ID(ex_val, 0);
		 }
		 else
		 {
			PJMEDIA_RTP_RD_EX_SET_PTT_ID(ex_val, stream->pttId);
		 }

		 PJMEDIA_RTP_RD_EX_SET_VF(ex_val, stream->rtp_ext_received);
		 stream->rtp_ext_received = PJ_FALSE;

		 if (req_MAM)
		 {
			 //Si pedimos MAM tenemos que enviar un length de 2
			 ex_hdr = 0x02006701;
		 }
		 else if (send_MAM)
		 {
			 if (stream->ED137version == 'C')
				 ex_hdr = 0x05006701;			//El MAM son 5 palabras de 32 bits en ED137C
			 else
				 ex_hdr = 0x04006701;			//El MAM son 4 palabras de 32 bits en ED137B
		 }

		 /*Aqui ponemos los valores forzados si procede. Simulo datos de PTT mute en el RTP*/
		 if (stream->radio_ua == PJ_TRUE)
		 {			 
			 if (stream->GRS_force_ptt_in_RTPRx_confirmed)
			 {
				 if (stream->GRS_force_ptt_mute_in_RTPRx) PJMEDIA_RTP_RD_EX_SET_PM(ex_val, 1);
				 PJMEDIA_RTP_RD_EX_SET_PTT_TYPE(ex_val, stream->GRS_forced_ptt_type_value_in_RTPRx);
				 //El PTT-id no se pone ya que por aqui deberia pasar solo si hay un squelch de avion con ptt-id cero
			 }
			 if (stream->GRS_force_SCT_in_RTPRx)
			 {
				 //Se pone a 1 el bit de mayor peso de los 3 bits RESERVED
				 current_reserved = PJMEDIA_RTP_RD_EX_GET_RESERVED(ex_val);
				 current_reserved |= 0x4;
				 PJMEDIA_RTP_RD_EX_SET_RESERVED(ex_val, current_reserved);
			 }

			 if (stream->SelCalInProgress)
			 {
				 if (PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(ex_val) == RTP_PTT_OFF)
				 {
					 PJMEDIA_RTP_RD_EX_SET_PTT_TYPE(ex_val, RTP_PTT_NORMAL);
					 PJMEDIA_RTP_RD_EX_SET_PTT_ID(ex_val, PJMEDIA_SELCAL_PTT_ID);
				 }
				 else
				 {
					 //Si hay otro PTT activo cancelamos el SELCAL
					 stream->SelCalInProgress = PJ_FALSE;
				 }
			 }
		 }

		 if (stream->Force_PTTS_in_RTPTxRx)
		 {
			 PJMEDIA_RTP_RD_EX_SET_PTTS(ex_val, 1);
		 }

		 pj_memcpy((char*)channel->out_pkt + sizeof(pjmedia_rtp_hdr), &ex_hdr, sizeof(pj_uint32_t));

		 if (req_MAM)
		 {
			 add_rmm_packet(stream, (char*)channel->out_pkt + sizeof(pjmedia_rtp_hdr) + sizeof(ex_hdr), ex_val);
		 }
		 else if (send_MAM)
		 {
			 add_mam_packet(stream, (char*)channel->out_pkt + sizeof(pjmedia_rtp_hdr) + sizeof(ex_hdr), ex_val, mam_T1, mam_T2, mam_Tj1, mam_Tid, mam_Ts2);
		 }
		 else
		 {
			pj_memcpy((char*)channel->out_pkt + sizeof(pjmedia_rtp_hdr) + sizeof(pj_uint32_t), &ex_val, sizeof(pj_uint32_t));

			if (stream->radio_ua && PJMEDIA_RTP_RD_EX_GET_TYPE(stream->rtp_ext_tx_info) == 1)
			{
				//Si estamos enviando el qidx, porque somos un simulador de radio, entonces no borramos
				//la extension de cabecera
			}
			else
			{
				if (PJMEDIA_RTP_RD_EX_GET_X(ex_val))
				{
					//Si no es un request MAM y se ha enviado una extension de cabecera con TLV
					//Entonces borramos el TLV para que en el siguiente rtp no lo lleve
					PJMEDIA_RTP_RD_EX_SET_X(stream->rtp_ext_tx_info, 0);			
					PJMEDIA_RTP_RD_EX_SET_TYPE(stream->rtp_ext_tx_info, 0);
					PJMEDIA_RTP_RD_EX_SET_LENGTH(stream->rtp_ext_tx_info, 0);
					PJMEDIA_RTP_RD_EX_SET_CLD(stream->rtp_ext_tx_info, 0);
				}
			}
		 }
		 
		 channel->rtp.out_hdr.x = 1;
	 }
	 else if (!stream->rtp_ext_enabled)
	 {
		 channel->rtp.out_hdr.x = 0;
	 }

    /* Copy RTP header to the beginning of packet */
    pj_memcpy(channel->out_pkt, rtphdr, sizeof(pjmedia_rtp_hdr));

    /* Special case for DTMF: timestamp remains constant for
     * the same event, and is only updated after a complete event
     * has been transmitted.
     */
    if (inc_timestamp) {
	pjmedia_rtp_encode_rtp( &channel->rtp, stream->tx_event_pt, 0,
				0, inc_timestamp, NULL, NULL);
    }

    /* Set RTP marker bit if currently not streaming */
    if (stream->is_streaming == PJ_FALSE) {
	pjmedia_rtp_hdr *rtp = (pjmedia_rtp_hdr*) channel->out_pkt;

	rtp->m = 1;
	PJ_LOG(5,(stream->port.info.name.ptr,"Start talksprut.."));

	stream->is_streaming = PJ_TRUE;
    }	
	
	pj_lock_acquire(stream->p_latency_lock);

	/*Se ejecutan los impairments*/
	if (stream->ImpDat.Perdidos && (!(pj_rand()%stream->ImpDat.Perdidos)))			//Perdemos aletoriamente paquetes
	{
		enviar_paquete_rtp_por_impairement = PJ_FALSE;
	}
	
	if (enviar_paquete_rtp_por_impairement == PJ_TRUE)
	{
		if (stream->ImpDat.Duplicados && (!(pj_rand() % stream->ImpDat.Duplicados)))		//Duplicamos aletoriamente paquetes
		{
			if (stream->ImpDat.LatMax && stream->ImpDat.p_timerheap_latency)
			{
				int cdup;
				int latency = stream->ImpDat.LatMax == stream->ImpDat.LatMin ? stream->ImpDat.LatMin : stream->ImpDat.LatMin + (pj_rand() % (stream->ImpDat.LatMax - stream->ImpDat.LatMin));

				for (cdup = 0; cdup < 2; cdup++)
				{
					void* copia_pkt = malloc(frame_out.size + rtp_hdr_size + sizeof(MYDATA));
					MYDATA* MyData = (MYDATA*)copia_pkt;
					MyData->stream = stream;
					MyData->size = frame_out.size + rtp_hdr_size;
					MyData->pkt = &MyData[1];

					memcpy((void*)&MyData[1], channel->out_pkt, frame_out.size + rtp_hdr_size);
					enviar_paquete_rtp_por_impairement = PJ_FALSE;

					pj_time_val delay;
					delay.sec = 0;
					delay.msec = latency;
					pj_time_val_normalize(&delay);

					pj_timer_heap_cancel(stream->ImpDat.p_timerheap_latency, &stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count]);
					if (stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count].user_data != NULL)
					{
						MYDATA* pMyData = (MYDATA*)stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count].user_data;
						free(pMyData);
						stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count].user_data = NULL;
					}

					stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count].user_data = (void*)MyData;
					status = pj_timer_heap_schedule(stream->ImpDat.p_timerheap_latency, &stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count], &delay);
					if (status != PJ_SUCCESS)
					{
						PJ_LOG(3, (THIS_FILE, "ERROR: timer_entry_latency fail"));
					}
					else
					{
						stream->ImpDat.timer_entry_latency_count++;
						if (stream->ImpDat.timer_entry_latency_count == STREAM_MAX_LATENCY_TIMER_HEAP) stream->ImpDat.timer_entry_latency_count = 0;
					}
				}
			}
			else
			{
				pjmedia_transport_send_rtp(stream->transport, channel->out_pkt,
					frame_out.size + rtp_hdr_size);
			}
		}
		else if (stream->ImpDat.LatMax && stream->ImpDat.p_timerheap_latency)
		{
			int latency = stream->ImpDat.LatMax == stream->ImpDat.LatMin ? stream->ImpDat.LatMin : stream->ImpDat.LatMin + (pj_rand() % (stream->ImpDat.LatMax - stream->ImpDat.LatMin));

			void* copia_pkt = malloc(frame_out.size + rtp_hdr_size + sizeof(MYDATA));
			MYDATA* MyData = (MYDATA*)copia_pkt;
			MyData->stream = stream;
			MyData->size = frame_out.size + rtp_hdr_size;
			MyData->pkt = &MyData[1];

			memcpy((void*)&MyData[1], channel->out_pkt, frame_out.size + rtp_hdr_size);
			enviar_paquete_rtp_por_impairement = PJ_FALSE;

			pj_time_val delay;
			delay.sec = 0;
			delay.msec = latency;
			pj_time_val_normalize(&delay);

			pj_timer_heap_cancel(stream->ImpDat.p_timerheap_latency, &stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count]);
			if (stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count].user_data != NULL)
			{
				MYDATA* pMyData = (MYDATA*)stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count].user_data;
				free(pMyData);
				stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count].user_data = NULL;
			}

			stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count].user_data = (void*)MyData;
			status = pj_timer_heap_schedule(stream->ImpDat.p_timerheap_latency, &stream->ImpDat.timer_entry_latency[stream->ImpDat.timer_entry_latency_count], &delay);
			if (status != PJ_SUCCESS)
			{
				PJ_LOG(3, (THIS_FILE, "ERROR: timer_entry_latency fail"));
			}
			else
			{
				stream->ImpDat.timer_entry_latency_count++;
				if (stream->ImpDat.timer_entry_latency_count == STREAM_MAX_LATENCY_TIMER_HEAP) stream->ImpDat.timer_entry_latency_count = 0;
			}
		}
	}

	pj_lock_release(stream->p_latency_lock);

    /* Send the RTP packet to the transport. */
	if (enviar_paquete_rtp_por_impairement == PJ_TRUE)
	{
		pjmedia_transport_send_rtp(stream->transport, channel->out_pkt, 
			frame_out.size + rtp_hdr_size);
	}

    /* Update stat */
    pjmedia_rtcp_tx_rtp(&stream->rtcp, (unsigned)frame_out.size);
    stream->rtcp.stat.rtp_tx_last_ts = pj_ntohl(stream->enc->rtp.out_hdr.ts);
    stream->rtcp.stat.rtp_tx_last_seq = pj_ntohs(stream->enc->rtp.out_hdr.seq);

    /* Update timestamp of last sending packet. */
    stream->last_frm_ts_sent = frame->timestamp;

    return PJ_SUCCESS;
}


/**
 * put_frame()
 *
 * This callback is called by upstream component when it has PCM frame
 * to transmit. This function encodes the PCM frame, pack it into
 * RTP packet, and transmit to peer.
 */
static pj_status_t put_frame( pjmedia_port *port, const pjmedia_frame *frame )
{
    pjmedia_stream *stream = (pjmedia_stream*) port->port_data.pdata;
    pjmedia_frame tmp_zero_frame;
    unsigned samples_per_frame;

    samples_per_frame = stream->enc_samples_per_pkt;	

    /* http://www.pjsip.org/trac/ticket/56:
     *  when input is PJMEDIA_FRAME_TYPE_NONE, feed zero PCM frame
     *  instead so that encoder can decide whether or not to transmit
     *  silence frame.
     */
    if (frame->type == PJMEDIA_FRAME_TYPE_NONE) 
	{
		pj_memcpy(&tmp_zero_frame, frame, sizeof(pjmedia_frame));
		frame = &tmp_zero_frame;

		tmp_zero_frame.buf = NULL;
		tmp_zero_frame.size = samples_per_frame * 2;
		tmp_zero_frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
    }

#if 0
    // This is no longer needed because each TYPE_NONE frame will
    // be converted into zero frame above

    /* If VAD is temporarily disabled during creation, feed zero PCM frame
     * to the codec.
     */
    if (stream->vad_enabled != stream->codec_param.setting.vad &&
	stream->vad_enabled != 0 &&
	frame->type == PJMEDIA_FRAME_TYPE_NONE &&
	samples_per_frame <= ZERO_PCM_MAX_SIZE)
    {
	pj_memcpy(&tmp_in_frame, frame, sizeof(pjmedia_frame));
	frame = &tmp_in_frame;

	tmp_in_frame.buf = NULL;
	tmp_in_frame.size = samples_per_frame * 2;
	tmp_in_frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
    }
#endif

    /* If VAD is temporarily disabled during creation, enable it
     * after transmitting for VAD_SUSPEND_SEC seconds.
     */
    if (stream->vad_enabled != stream->codec_param.setting.vad && 
		(stream->tx_duration - stream->ts_vad_disabled) > stream->port.info.clock_rate * PJMEDIA_STREAM_VAD_SUSPEND_MSEC / 1000)
    {
		stream->codec_param.setting.vad = stream->vad_enabled;
		stream->codec->op->modify(stream->codec, &stream->codec_param);
		PJ_LOG(4,(stream->port.info.name.ptr,"VAD re-enabled"));
    }


    /* If encoder has different ptime than decoder, then the frame must
     * be passed through the encoding buffer via rebuffer() function.
     */
    if (stream->enc_buf != NULL) 
	{
		pjmedia_frame tmp_rebuffer_frame;
		pj_status_t status = PJ_SUCCESS;

		/* Copy original frame to temporary frame since we need 
		 * to modify it.
		 */
		pj_memcpy(&tmp_rebuffer_frame, frame, sizeof(pjmedia_frame));

		/* Loop while we have full frame in enc_buffer */
		for (;;) 
		{
			pj_status_t st;

			/* Run rebuffer() */
			rebuffer(stream, &tmp_rebuffer_frame);

			/* Process this frame */
			st = put_frame_imp(port, &tmp_rebuffer_frame);
			if (st != PJ_SUCCESS)
			status = st;

			/* If we still have full frame in the buffer, re-run
			 * rebuffer() with NULL frame.
			 */
			if (stream->enc_buf_count >= stream->enc_samples_per_pkt) 
			{
				tmp_rebuffer_frame.type = PJMEDIA_FRAME_TYPE_NONE;
			} 
			else 
			{
				/* Otherwise break */
				break;
			}
		}
		return status;

    } 
	else 
	{
		return put_frame_imp(port, frame);
    }
}


static pj_status_t reset( pjmedia_port *port )
{
	pjmedia_stream *stream = (pjmedia_stream*) port->port_data.pdata;

	pj_mutex_lock( stream->jb_mutex );
	pjmedia_jbuf_reset(stream->jb);
	pj_mutex_unlock( stream->jb_mutex );

	PJ_LOG(4,(stream->port.info.name.ptr, "Decoder stream reset"));

	return PJ_SUCCESS;
}

#if 0
static void dump_bin(const char *buf, unsigned len)
{
    unsigned i;

    PJ_LOG(3,(THIS_FILE, "begin dump"));
    for (i=0; i<len; ++i) {
	int j;
	char bits[9];
	unsigned val = buf[i] & 0xFF;

	bits[8] = '\0';
	for (j=0; j<8; ++j) {
	    if (val & (1 << (7-j)))
		bits[j] = '1';
	    else
		bits[j] = '0';
	}

	PJ_LOG(3,(THIS_FILE, "%2d %s [%d]", i, bits, val));
    }
    PJ_LOG(3,(THIS_FILE, "end dump"));
}
#endif

/*
 * Handle incoming DTMF digits.
 */
static void handle_incoming_dtmf( pjmedia_stream *stream, 
				  const void *payload, unsigned payloadlen)
{
    pjmedia_rtp_dtmf_event *event = (pjmedia_rtp_dtmf_event*) payload;

    /* Check compiler packing. */
    pj_assert(sizeof(pjmedia_rtp_dtmf_event)==4);

    /* Must have sufficient length before we proceed. */
    if (payloadlen < sizeof(pjmedia_rtp_dtmf_event))
	return;

    //dump_bin(payload, payloadlen);

    /* Check if this is the same/current digit of the last packet. */
    if (stream->last_dtmf != -1 &&
	event->event == stream->last_dtmf &&
	pj_ntohs(event->duration) >= stream->last_dtmf_dur)
    {
	/* Yes, this is the same event. */
	stream->last_dtmf_dur = pj_ntohs(event->duration);
	return;
    }

    /* Ignore unknown event. */
    if (event->event > 15) {
	PJ_LOG(5,(stream->port.info.name.ptr, 
		  "Ignored RTP pkt with bad DTMF event %d",
    		  event->event));
	return;
    }

    /* New event! */
    PJ_LOG(5,(stream->port.info.name.ptr, "Received DTMF digit %c, vol=%d",
    	      digitmap[event->event],
    	      (event->e_vol & 0x3F)));

    stream->last_dtmf = event->event;
    stream->last_dtmf_dur = pj_ntohs(event->duration);

    /* If DTMF callback is installed, call the callback, otherwise keep
     * the DTMF digits in the buffer.
     */
    if (stream->dtmf_cb) {

	stream->dtmf_cb(stream, stream->dtmf_cb_user_data, 
			digitmap[event->event]);

    } else {
	/* By convention, we use jitter buffer's mutex to access shared
	 * DTMF variables.
	 */
	pj_mutex_lock(stream->jb_mutex);
	if (stream->rx_dtmf_count >= PJ_ARRAY_SIZE(stream->rx_dtmf_buf)) {
	    /* DTMF digits overflow.  Discard the oldest digit. */
	    pj_array_erase(stream->rx_dtmf_buf, 
			   sizeof(stream->rx_dtmf_buf[0]),
			   stream->rx_dtmf_count, 0);
	    --stream->rx_dtmf_count;
	}
	stream->rx_dtmf_buf[stream->rx_dtmf_count++] = digitmap[event->event];
	pj_mutex_unlock(stream->jb_mutex);
    }
}


/*
 * This callback is called by stream transport on receipt of packets
 * in the RTP socket. 
 */
static void on_rx_rtp( void *data, 
		       void *pkt,
                       pj_ssize_t bytes_read)

{
    pjmedia_stream *stream = (pjmedia_stream*) data;
    pjmedia_channel *channel = stream->dec;
    const pjmedia_rtp_hdr *hdr;
    const void *payload;
    unsigned payloadlen;
    pjmedia_rtp_status seq_st;
    pj_status_t status;
    pj_bool_t pkt_discarded = PJ_FALSE;
    pj_uint32_t rtp_ext_info = 0;
	pj_uint32_t rtp_ext_info_1st = 0;
	const void *p_rtp_ext_info = NULL;
	pj_uint32_t rtp_ext_length = 0;   //Cantidad de palabras de 32 bits de la extensi�n de cabecera
	pj_uint32_t i = 0;
	pj_uint32_t *p_rtp_ext_info_aux;
	pj_bool_t not_equal_ext_header = PJ_FALSE;
	pjmedia_rtp_ext_hdr ext_type_length;
	pj_bool_t GRS_force_ptt_in_RTPRx_confirmed_prev = PJ_FALSE;
	pj_bool_t GRS_force_ptt_mute_in_RTPRx_changed = PJ_FALSE;

    /* Check for errors */
    if (bytes_read < 0) {
		LOGERR_((stream->port.info.name.ptr, "RTP recv() error", (pj_status_t)-bytes_read));
		return;
    }

    /* Ignore keep-alive packets */
    if (bytes_read < (pj_ssize_t) sizeof(pjmedia_rtp_hdr))
		return;

    /* Update RTP and RTCP session. */
    status = pjmedia_rtp_decode_rtp(&channel->rtp, pkt, (int)bytes_read,
		&hdr, &ext_type_length, &rtp_ext_info, &p_rtp_ext_info, &rtp_ext_length, &payload, &payloadlen);
    if (status != PJ_SUCCESS) {
		LOGERR_((stream->port.info.name.ptr, "RTP decode error", status));
		stream->rtcp.stat.rx.discard++;
		return;
    }
	
    /* Update RTP session (also checks if RTP session can accept
     * the incoming packet.
     */
    pjmedia_rtp_session_update2(&channel->rtp, hdr, &seq_st,
		(hdr->pt != stream->rx_event_pt) && (hdr->pt != 123));
    if (seq_st.status.value) {
		TRC_  ((stream->port.info.name.ptr, 
			"RTP status: badpt=%d, badssrc=%d, dup=%d, "
			"outorder=%d, probation=%d, restart=%d", 
			seq_st.status.flag.badpt,
			seq_st.status.flag.badssrc,
			seq_st.status.flag.dup,
			seq_st.status.flag.outorder,
			seq_st.status.flag.probation,
			seq_st.status.flag.restart));

		if (seq_st.status.flag.badpt) {
			PJ_LOG(4,(stream->port.info.name.ptr,
				  "Bad RTP pt %d (expecting %d)",
				hdr->pt, channel->rtp.out_pt));
		}

		if (seq_st.status.flag.badssrc) {
			PJ_LOG(4,(stream->port.info.name.ptr,
		      "Changed RTP peer SSRC %d (previously %d)",
		      channel->rtp.peer_ssrc, stream->rtcp.peer_ssrc));
			stream->rtcp.peer_ssrc = channel->rtp.peer_ssrc;
		}
    }

    /* Skip bad RTP packet */
    if (seq_st.status.flag.bad) {
		pkt_discarded = PJ_TRUE;
		goto on_return;
    }

	/* Hemos recibido un paquete v�lido */

	 if (stream->rtp_ext_enabled || rtp_ext_length != 0)
	 {
		 stream->rtp_ext_received = PJ_TRUE;

		 rtp_ext_info_1st = rtp_ext_info;	//Nos quedamos con la primera extensi�n de cabecera
											//Es la que se env�a en la callback on_stream_rtp

		 if (PJMEDIA_RTP_RD_EX_GET_VF(rtp_ext_info))
		 {
			 stream->ka_received = PJ_TRUE;
			 PJMEDIA_RTP_RD_EX_SET_VF(rtp_ext_info, 0);
		 }

		 p_rtp_ext_info_aux = (pj_uint32_t *) p_rtp_ext_info;

		 if ((rtp_ext_length != 0) && (stream->last_rtp_ext_length != rtp_ext_length))
		 {
			not_equal_ext_header = PJ_TRUE;
		 }
		 else
		 {
			 for (i = 0; i < rtp_ext_length; i++)
			 {
				if (stream->last_ext_header[i] != *p_rtp_ext_info_aux)
				{
					not_equal_ext_header = PJ_TRUE;
					break;
				}
				p_rtp_ext_info_aux++;
			 }
		 }

		 if (stream->tx_pttmute_changed == PJ_TRUE)
		 {
			 //Forzamos la llamada de on_stream_rtp_ext_info_changed cuando hay un cambio en el mute de transmision			 
			 not_equal_ext_header = PJ_TRUE;
		 }

		 GRS_force_ptt_in_RTPRx_confirmed_prev = stream->GRS_force_ptt_in_RTPRx_confirmed;
		 if (stream->radio_ua && (stream->GRS_force_ptt_mute_in_RTPRx || stream->GRS_force_ptt_in_RTPRx))
		 {
			 if (PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(rtp_ext_info) == RTP_PTT_OFF)
			 {
				 stream->GRS_force_ptt_in_RTPRx_confirmed = PJ_TRUE;
			 }
			 else if (PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(rtp_ext_info) == RTP_PTT_TEST && 
				 (stream->GRS_forced_ptt_type_value_in_RTPRx == RTP_PTT_NORMAL || stream->GRS_forced_ptt_type_value_in_RTPRx == RTP_PTT_COUPLING || 
					 stream->GRS_forced_ptt_type_value_in_RTPRx == RTP_PTT_PRIORITY || stream->GRS_forced_ptt_type_value_in_RTPRx == RTP_PTT_EMERGENCY))
			 {
				 stream->GRS_force_ptt_in_RTPRx_confirmed = PJ_TRUE;
			 }
			 else if (((PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(rtp_ext_info) == RTP_PTT_NORMAL || PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(rtp_ext_info) == RTP_PTT_COUPLING) &&
				 (stream->GRS_forced_ptt_type_value_in_RTPRx == RTP_PTT_NORMAL || stream->GRS_forced_ptt_type_value_in_RTPRx == RTP_PTT_COUPLING)) &&
				 stream->GRS_force_ptt_in_RTPRx_confirmed)
			 {
				 stream->GRS_force_ptt_in_RTPRx_confirmed = PJ_TRUE;
			 }
			 else if (PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(rtp_ext_info) == stream->GRS_forced_ptt_type_value_in_RTPRx &&
				 stream->GRS_force_ptt_in_RTPRx_confirmed)
			 {
				 stream->GRS_force_ptt_in_RTPRx_confirmed = PJ_TRUE;
			 }
			 else if ((stream->GRS_forced_ptt_type_value_in_RTPRx == RTP_PTT_PRIORITY || stream->GRS_forced_ptt_type_value_in_RTPRx == RTP_PTT_EMERGENCY) &&
				 (stream->GRS_forced_ptt_type_value_in_RTPRx > PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(rtp_ext_info) || PJMEDIA_RTP_RD_EX_GET_PTT_TYPE(rtp_ext_info) == RTP_PTT_TEST))
			 {
				 stream->GRS_force_ptt_in_RTPRx_confirmed = PJ_TRUE;
			 }
			 else
			 {
				 stream->GRS_force_ptt_in_RTPRx_confirmed = PJ_FALSE;
			 }
		 }
		 else
		 {
			 stream->GRS_force_ptt_in_RTPRx_confirmed = PJ_FALSE;
		 }

		 if (stream->GRS_force_ptt_mute_in_RTPRx || stream->GRS_force_ptt_in_RTPRx)
		 {
			if (GRS_force_ptt_in_RTPRx_confirmed_prev != stream->GRS_force_ptt_in_RTPRx_confirmed)
			{	 
				GRS_force_ptt_mute_in_RTPRx_changed = PJ_TRUE;
				not_equal_ext_header = PJ_TRUE;	//para forzar la llamada a la callback					 
			}			 
		 }

		 if (not_equal_ext_header)
		 {
			 stream->reenv_info_count = 3;
		 }

		 if (stream->reenv_info_count != 0)
		 {
			stream->reenv_info_count--;
			//Se llama la callback si cambia el contenido de la extensi�n de cabecera
			if (pj_app_cbs.on_stream_rtp_ext_info_changed)
			{
				pj_app_cbs.on_stream_rtp_ext_info_changed(stream, (void *) &ext_type_length, rtp_ext_info, p_rtp_ext_info, rtp_ext_length, stream->tx_pttmute_changed, 
					GRS_force_ptt_mute_in_RTPRx_changed);
			}
		 }		 

		 stream->tx_pttmute_changed = PJ_FALSE;
	 }
	 else
	 {
		 stream->GRS_force_ptt_in_RTPRx_confirmed = PJ_FALSE;
	 }

	 stream->last_rtp_ext_length = rtp_ext_length;
	 p_rtp_ext_info_aux = (pj_uint32_t *) p_rtp_ext_info;
	 for (i = 0; i < rtp_ext_length; i++)
	 {
		stream->last_ext_header[i] = *p_rtp_ext_info_aux;
		p_rtp_ext_info_aux++;
	 }

    /* Ignore if payloadlen is zero */
    if (payloadlen == 0) {
		pkt_discarded = PJ_TRUE;
		goto on_return;
    }

	/* Ignore the packet if decoder is paused */
	if (channel->paused)
		goto on_return;

    /* Handle incoming DTMF. */
    if (hdr->pt == stream->rx_event_pt) {
		/* Ignore out-of-order packet as it will be detected as new
		 * digit. Also ignore duplicate packet as it serves no use.
		 */
		if (seq_st.status.flag.outorder || seq_st.status.flag.dup) {
			goto on_return;
		}

		handle_incoming_dtmf(stream, payload, payloadlen);
		goto on_return;
    }

    /* Put "good" packet to jitter buffer, or reset the jitter buffer
     * when RTP session is restarted.
     */
    pj_mutex_lock( stream->jb_mutex );
    if (seq_st.status.flag.restart) {
		status = pjmedia_jbuf_reset(stream->jb);
		PJ_LOG(4,(stream->port.info.name.ptr, "Jitter buffer reset"));

		if (stream->rtp_ext_enabled && pj_app_cbs.on_stream_rtp)
		{
			pj_app_cbs.on_stream_rtp(stream, NULL, NULL, 0, rtp_ext_info_1st);
		}

    } else {
		/*
		 * Packets may contain more than one frames, while the jitter
		 * buffer can only take one frame per "put" operation. So we need
		 * to ask the codec to "parse" the payload into multiple frames.
		 */
		enum { MAX = 16 };
		pj_timestamp ts;
		unsigned i, count = MAX;
		unsigned ts_span;
		pjmedia_frame frames[MAX];

		/* Get the timestamp of the first sample */
		ts.u64 = pj_ntohl(hdr->ts);

		/* Parse the payload. */
		status = (*stream->codec->op->parse)(stream->codec,
							 (void*)payload,
							 payloadlen,
							 &ts,
							 &count,
							 frames);
		if (status != PJ_SUCCESS) {
			LOGERR_((stream->port.info.name.ptr, 
				 "Codec parse() error", 
				 status));
			count = 0;
		}

#if defined(PJMEDIA_HANDLE_G722_MPEG_BUG) && (PJMEDIA_HANDLE_G722_MPEG_BUG!=0)
		/* This code is used to learn the samples per frame value that is put
		 * by remote endpoint, for codecs with inconsistent clock rate such
		 * as G.722 or MPEG audio. We need to learn the samples per frame 
		 * value as it is used as divider when inserting frames into the
		 * jitter buffer.
		 */
		if (stream->has_g722_mpeg_bug) {
			if (stream->rtp_rx_check_cnt) {
				/* Make sure the detection performed only on two consecutive 
				 * packets with valid RTP sequence and no wrapped timestamp.
				 */
				if (seq_st.diff == 1 && stream->rtp_rx_last_ts && 
					ts.u64 > stream->rtp_rx_last_ts)
				{
					unsigned peer_frm_ts_diff;

					peer_frm_ts_diff = 
					((pj_uint32_t)ts.u64-stream->rtp_rx_last_ts) / 
					stream->rtp_rx_last_cnt;

					/* Possibilities remote's samples per frame for G.722 
					 * are only 160 and 320, this validation is needed
					 * to avoid wrong decision because of silence frames.
					 */
					if (stream->codec_param.info.pt == PJMEDIA_RTP_PT_G722 &&
					(peer_frm_ts_diff==stream->port.info.samples_per_frame
					 || peer_frm_ts_diff == 
							stream->port.info.samples_per_frame >> 1))
					{
						if (peer_frm_ts_diff < stream->rtp_rx_ts_len_per_frame)
							stream->rtp_rx_ts_len_per_frame = peer_frm_ts_diff;

						if (--stream->rtp_rx_check_cnt == 0) {
    						PJ_LOG(4, (THIS_FILE, "G722 codec used, remote"
							   " samples per frame detected = %d", 
							   stream->rtp_rx_ts_len_per_frame));
			    
							/* Reset jitter buffer once detection done */
							pjmedia_jbuf_reset(stream->jb);

							if (stream->rtp_ext_enabled && pj_app_cbs.on_stream_rtp)
							{
								pj_app_cbs.on_stream_rtp(stream, NULL, NULL, 0, rtp_ext_info_1st);
							}
						}
					}
				}

				stream->rtp_rx_last_ts = (pj_uint32_t)ts.u64;
				stream->rtp_rx_last_cnt = count;
			}

			ts_span = stream->rtp_rx_ts_len_per_frame;

		} else {
			ts_span = stream->codec_param.info.frm_ptime * 
				  stream->codec_param.info.clock_rate /
				  1000;
		}
#else
	ts_span = stream->codec_param.info.frm_ptime * 
		  stream->codec_param.info.clock_rate /
		  1000;
#endif

		/* Put each frame to jitter buffer. */
		for (i=0; i<count; ++i) {
			unsigned ext_seq;
			pj_bool_t discarded;

			ext_seq = (unsigned)(frames[i].timestamp.u64 / ts_span);
			pjmedia_jbuf_put_frame2(stream->jb, frames[i].buf, frames[i].size,
						frames[i].bit_info, ext_seq, &discarded);
			if (discarded)
				pkt_discarded = PJ_TRUE;

			if (stream->rtp_ext_enabled && pj_app_cbs.on_stream_rtp)
			{
				 pj_app_cbs.on_stream_rtp(stream, &frames[i], stream->codec, ext_seq, rtp_ext_info_1st);
			}

			if (stream->is_for_coresip_RTPport && pj_app_cbs.on_stream_rtp_RTPport)
			{
				//Llamamos a la callback del RTPport, por si necesita analizar RTP
				pj_app_cbs.on_stream_rtp_RTPport(stream, &frames[i], stream->codec, ext_seq, rtp_ext_info_1st);
			}
		}
    }
    pj_mutex_unlock( stream->jb_mutex );


    /* Check if now is the time to transmit RTCP SR/RR report.
     * We only do this when stream direction is "decoding only", 
     * because otherwise check_tx_rtcp() will be handled by put_frame()
     */
    if (stream->dir == PJMEDIA_DIR_DECODING) {
		check_tx_rtcp(stream, pj_ntohl(hdr->ts));
    }

    if (status != 0) {
		LOGERR_((stream->port.info.name.ptr, "Jitter buffer put() error", 
			status));
		pkt_discarded = PJ_TRUE;
		goto on_return;
    }

on_return:
    /* Update RTCP session */
    if (stream->rtcp.peer_ssrc == 0)
	stream->rtcp.peer_ssrc = channel->rtp.peer_ssrc;

    pjmedia_rtcp_rx_rtp2(&stream->rtcp, pj_ntohs(hdr->seq),
			 pj_ntohl(hdr->ts), payloadlen, pkt_discarded);

    /* Send RTCP RR and SDES after we receive some RTP packets */
    if (stream->rtcp.received >= 10 && !stream->initial_rr) {
	void *sr_rr_pkt;
	pj_uint8_t *pkt;
	int len;

	/* Build RR or SR */
	pjmedia_rtcp_build_rtcp(&stream->rtcp, &sr_rr_pkt, &len);
	pkt = (pj_uint8_t*) stream->enc->out_pkt;
	pj_memcpy(pkt, sr_rr_pkt, len);
	pkt += len;

	/* Append SDES */
	len = create_rtcp_sdes(stream, (pj_uint8_t*)pkt, 
			       stream->enc->out_pkt_size - len);
	if (len > 0) {
		pj_size_t len_to_send;
	    pkt += len;
		len_to_send = ((pj_uint8_t*)pkt) - ((pj_uint8_t*)stream->enc->out_pkt);
	    pjmedia_transport_send_rtcp(stream->transport, 
					stream->enc->out_pkt, len_to_send);
	}

	stream->initial_rr = PJ_TRUE;
    }
}


/*
 * This callback is called by stream transport on receipt of packets
 * in the RTCP socket. 
 */
static void on_rx_rtcp( void *data,
                        void *pkt, 
                        pj_ssize_t bytes_read)
{
    pjmedia_stream *stream = (pjmedia_stream*) data;

    /* Check for errors */
    if (bytes_read < 0) {
	LOGERR_((stream->port.info.name.ptr, "RTCP recv() error", 
		 (pj_status_t) -bytes_read));
	return;
    }

    pjmedia_rtcp_rx_rtcp(&stream->rtcp, pkt, bytes_read);
}


/*
 * Create media channel.
 */
static pj_status_t create_channel( pj_pool_t *pool,
				   pjmedia_stream *stream,
				   pjmedia_dir dir,
				   unsigned pt,
				   const pjmedia_stream_info *param,
				   pjmedia_channel **p_channel)
{
    pjmedia_channel *channel;
    pj_status_t status;
    unsigned min_out_pkt_size;
    
    /* Allocate memory for channel descriptor */

    channel = PJ_POOL_ZALLOC_T(pool, pjmedia_channel);
    PJ_ASSERT_RETURN(channel != NULL, PJ_ENOMEM);

    /* Init channel info. */

    channel->stream = stream;
    channel->dir = dir;
    channel->paused = 1;
    channel->pt = pt;

    
    /* Allocate buffer for outgoing packet. */

    channel->out_pkt_size = sizeof(pjmedia_rtp_hdr) + 
			    stream->codec_param.info.max_bps * 
			    PJMEDIA_MAX_FRAME_DURATION_MS / 
			    8 / 1000;

    if (channel->out_pkt_size > PJMEDIA_MAX_MTU)
	channel->out_pkt_size = PJMEDIA_MAX_MTU;

    /* It should big enough to hold (minimally) RTCP SR with an SDES. */
    min_out_pkt_size = (unsigned) (sizeof(pjmedia_rtcp_sr_pkt) +
			sizeof(pjmedia_rtcp_common) +
			(4 + stream->cname.slen) +
			32);

    if (channel->out_pkt_size < min_out_pkt_size)
	channel->out_pkt_size = min_out_pkt_size;

    channel->out_pkt = pj_pool_alloc(pool, channel->out_pkt_size);
    PJ_ASSERT_RETURN(channel->out_pkt != NULL, PJ_ENOMEM);



    /* Create RTP and RTCP sessions: */

    if (param->rtp_seq_ts_set == 0) {
	status = pjmedia_rtp_session_init(&channel->rtp, pt, param->ssrc);
    } else {
	pjmedia_rtp_session_setting settings;

	settings.flags = (pj_uint8_t)((param->rtp_seq_ts_set << 2) | 3);
	settings.default_pt = pt;
	settings.sender_ssrc = param->ssrc;
	settings.seq = param->rtp_seq;
	settings.ts = param->rtp_ts;
	status = pjmedia_rtp_session_init2(&channel->rtp, settings);
    }
    if (status != PJ_SUCCESS)
	return status;

    /* Done. */
    *p_channel = channel;
    return PJ_SUCCESS;
}


PJ_DEF(void) pjmedia_stream_set_rtp_ext_tx_info(pjmedia_stream * stream, pj_uint32_t rtp_ext_tx_info)
{
	pj_uint32_t prev_ptt_mute, new_ptt_mute;
	if (stream)
	{
		prev_ptt_mute = PJMEDIA_RTP_RD_EX_GET_PM(stream->rtp_ext_tx_info);
		new_ptt_mute = PJMEDIA_RTP_RD_EX_GET_PM(rtp_ext_tx_info);
		if (prev_ptt_mute != new_ptt_mute)
		{
			stream->tx_pttmute_changed = PJ_TRUE;
		}
		stream->rtp_ext_tx_info = rtp_ext_tx_info;
	}
}

PJ_DEF(void) pjmedia_stream_get_rtp_ext_tx_info(pjmedia_stream * stream, pj_uint32_t *rtp_ext_tx_info)
{
	if (stream && rtp_ext_tx_info)
		*rtp_ext_tx_info = stream->rtp_ext_tx_info;
}

PJ_DEF(void) pjmedia_stream_get_last_T1(pjmedia_stream * stream, pj_uint32_t *last_T1)
{
	if (stream && last_T1)
		*last_T1 = stream->last_T1;
}

/*
* Get user data.
*/
PJ_DEF(void*) pjmedia_stream_get_user_data( pjmedia_stream *stream)
{
	return (stream? stream->user_data : NULL);
}

/*
 * Modify media stream only for radio sessions.
 */
PJ_DEF(pj_status_t) pjmedia_radio_stream_modify(pjmedia_stream* stream, const pjmedia_stream_info* info)
{
	pj_status_t status;

	status = stream->codec->op->modify(stream->codec, info->param);

	if (status == PJ_SUCCESS)
	{
		//Se actualiza el formato del payload
		stream->enc->rtp.out_pt = (pj_uint16_t) info->tx_pt;
		stream->enc->pt = info->tx_pt;
		stream->dec->rtp.out_pt = (pj_uint16_t) info->fmt.pt;
		stream->dec->pt = info->fmt.pt;
	}
	
	return status;
}

static int PJ_THREAD_FUNC latency_proc(void* arg)
{
	pjmedia_stream* stream = (pjmedia_stream*)arg;

	while (!stream->ImpDat.platency_thread_quit)
	{		
		pj_thread_sleep(1);
		if (stream->ImpDat.p_timerheap_latency) pj_timer_heap_poll(stream->ImpDat.p_timerheap_latency, NULL);
	}

	return 0;
}

pj_status_t pjmedia_stream_latency_create(pj_pool_t* pool, pjmedia_stream *stream)
{
	pj_status_t status = PJ_SUCCESS;
	pj_lock_t* timerheap_latency_lock = NULL;
	int i;

	PJ_ASSERT_RETURN(pool && stream->ImpDat.p_timerheap_latency == NULL && stream->ImpDat.platency_thread == NULL, PJ_EINVAL);

	status = pj_timer_heap_create(pool, STREAM_MAX_LATENCY_TIMER_HEAP, &stream->ImpDat.p_timerheap_latency);
	if (status != PJ_SUCCESS)
	{
		stream->ImpDat.p_timerheap_latency = NULL;
		return status;
	}

	status = pj_lock_create_recursive_mutex(pool, "latency%p", &timerheap_latency_lock);
	if (status != PJ_SUCCESS) {
		pj_timer_heap_destroy(stream->ImpDat.p_timerheap_latency);
		stream->ImpDat.p_timerheap_latency = NULL;
		return status;
	}
	pj_timer_heap_set_lock(stream->ImpDat.p_timerheap_latency, timerheap_latency_lock, PJ_TRUE);

	for (i = 0; i < STREAM_MAX_LATENCY_TIMER_HEAP; i++)
	{
		pj_timer_entry_init(&stream->ImpDat.timer_entry_latency[i], i, NULL, timer_entry_latency_cb);
	}

	stream->ImpDat.platency_thread_quit = PJ_FALSE;
	status = pj_thread_create(pool, "latency_thread", &latency_proc, stream, 0, 0, &stream->ImpDat.platency_thread);
	if (status != PJ_SUCCESS)
	{
		pj_timer_heap_destroy(stream->ImpDat.p_timerheap_latency);
		stream->ImpDat.p_timerheap_latency = NULL;
		return status;
	}	

	return status;
}

pj_status_t pjmedia_stream_latency_destroy(pjmedia_stream* stream)
{
	pj_status_t status = PJ_SUCCESS;
	if (stream->ImpDat.p_timerheap_latency)
	{
		int i;
		for (i = 0; i < STREAM_MAX_LATENCY_TIMER_HEAP; i++)
		{
			pj_timer_heap_cancel(stream->ImpDat.p_timerheap_latency, &stream->ImpDat.timer_entry_latency[i]);
			if (stream->ImpDat.timer_entry_latency[i].user_data != NULL)
			{
				MYDATA* pMyData = (MYDATA*)stream->ImpDat.timer_entry_latency[i].user_data;
				free(pMyData);
				stream->ImpDat.timer_entry_latency[i].user_data = NULL;
			}
		}
	}

	if (stream->ImpDat.platency_thread)
	{
		stream->ImpDat.platency_thread_quit = PJ_TRUE;
		status = pj_thread_join(stream->ImpDat.platency_thread);
		if (status != PJ_SUCCESS) PJ_LOG(3, (__FILE__, "ERROR: pjmedia_stream_latency_destroy: pj_thread_join failed"));
		status = pj_thread_destroy(stream->ImpDat.platency_thread);
		if (status != PJ_SUCCESS) PJ_LOG(3, (__FILE__, "ERROR: pjmedia_stream_latency_destroy: pj_thread_destroy failed"));
		stream->ImpDat.platency_thread = NULL;
	}

	if (stream->ImpDat.p_timerheap_latency)
	{
		pj_timer_heap_destroy(stream->ImpDat.p_timerheap_latency);
		stream->ImpDat.p_timerheap_latency = NULL;
	}

	return status;
}

/*
 * Create media stream.
 */
PJ_DEF(pj_status_t) pjmedia_stream_create( pjmedia_endpt *endpt,
					   pj_pool_t *pool,
					   const pjmedia_stream_info *info,
					   pjmedia_transport *tp,
					   void *user_data,
					   pjmedia_stream **p_stream)

{
    enum { M = 32 };
    pjmedia_stream *stream = NULL;
    pj_str_t name;
    unsigned jb_init, jb_max, jb_min_pre, jb_max_pre, len;
    char *p;
    pj_status_t status;
	pjmedia_transport_info tpinfo;

    PJ_ASSERT_RETURN(pool && info && p_stream, PJ_EINVAL);

	*p_stream = NULL;

    /* Allocate the media stream: */

    stream = PJ_POOL_ZALLOC_T(pool, pjmedia_stream);
    PJ_ASSERT_RETURN(stream != NULL, PJ_ENOMEM);

    /* Init stream/port name */
    name.ptr = (char*) pj_pool_alloc(pool, M);
    name.slen = pj_ansi_snprintf(name.ptr, M, "strm%p", stream);

    /* Init some port-info. Some parts of the info will be set later
     * once we have more info about the codec.
     */
    pjmedia_port_info_init(&stream->port.info, &name,
			   PJMEDIA_PORT_SIGNATURE('S', 'T', 'R', 'M'),
			   info->fmt.clock_rate, info->fmt.channel_cnt,
			   16, 80);

    /* Init port. */

    pj_strdup(pool, &stream->port.info.encoding_name, &info->fmt.encoding_name);
    stream->port.info.clock_rate = info->fmt.clock_rate;
    stream->port.info.channel_count = info->fmt.channel_cnt;
    stream->port.port_data.pdata = stream;

    /* Init stream: */
    stream->endpt = endpt;
    stream->codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);
    stream->dir = info->dir;
    stream->user_data = user_data;
    stream->rtcp_interval = (PJMEDIA_RTCP_INTERVAL-500 + (pj_rand()%1000)) *
			    info->fmt.clock_rate / 1000;

    stream->tx_event_pt = info->tx_event_pt ? info->tx_event_pt : -1;
    stream->rx_event_pt = info->rx_event_pt ? info->rx_event_pt : -1;
    stream->last_dtmf = -1;
    stream->jb_last_frm = PJMEDIA_JB_NORMAL_FRAME;
	 stream->ka_type = info->ka_type;
	 stream->ka_remote_timeout = info->ka_remote_timeout;
	 stream->ka_local_interval = info->ka_local_interval;
	 stream->rtp_ext_enabled = info->rtp_ext_enabled;
	 /** AGL EL PTT-ID para los KA*/
	 stream->pttId = info->pttId;
	 stream->request_MAM = PJ_FALSE;
	 stream->radio_ua = PJ_FALSE;
	 stream->SQU_rep = 1;
	 stream->QoSHandle = INVALID_HANDLE_VALUE;
	 stream->ED137version = 'B';

    /* Build random RTCP CNAME. CNAME has user@host format */
    stream->cname.ptr = p = (char*) pj_pool_alloc(pool, 20);
    pj_create_random_string(p, 5);
    p += 5;
    *p++ = '@'; *p++ = 'p'; *p++ = 'j';
    pj_create_random_string(p, 6);
    p += 6;
    *p++ = '.'; *p++ = 'o'; *p++ = 'r'; *p++ = 'g';
    stream->cname.slen = p - stream->cname.ptr;	

	status = pj_lock_create_recursive_mutex(pool, NULL, &stream->p_latency_lock);
	if (status != PJ_SUCCESS)
		goto err_cleanup;

    /* Create mutex to protect jitter buffer: */

    status = pj_mutex_create_simple(pool, NULL, &stream->jb_mutex);
    if (status != PJ_SUCCESS)
	goto err_cleanup;

	status = pj_mutex_create_simple(pool, NULL, &stream->mam_mutex);
	if (status != PJ_SUCCESS)
		goto err_cleanup;


    /* Create and initialize codec: */

    status = pjmedia_codec_mgr_alloc_codec( stream->codec_mgr,
					    &info->fmt, &stream->codec);
    if (status != PJ_SUCCESS)
	goto err_cleanup;


    /* Get codec param: */
    if (info->param)
	stream->codec_param = *info->param;
    else {
	status = pjmedia_codec_mgr_get_default_param(stream->codec_mgr, 
						     &info->fmt, 
						     &stream->codec_param);
	if (status != PJ_SUCCESS)
	    goto err_cleanup;
    }

    /* Check for invalid max_bps. */
    if (stream->codec_param.info.max_bps < stream->codec_param.info.avg_bps)
	stream->codec_param.info.max_bps = stream->codec_param.info.avg_bps;

    /* Check for invalid frame per packet. */
    if (stream->codec_param.setting.frm_per_pkt < 1)
	stream->codec_param.setting.frm_per_pkt = 1;

    /* Open the codec. */
    status = stream->codec->op->open(stream->codec, &stream->codec_param);
    if (status != PJ_SUCCESS)
	goto err_cleanup;

    /* Set additional info. */
    stream->port.info.bits_per_sample = 16;
    stream->port.info.samples_per_frame = info->fmt.clock_rate * 
					  stream->codec_param.info.channel_cnt *
					  stream->codec_param.info.frm_ptime *
					  stream->codec_param.setting.frm_per_pkt /
					  1000;
    stream->port.info.bytes_per_frame = stream->codec_param.info.max_bps * 
					stream->codec_param.info.frm_ptime *
					stream->codec_param.setting.frm_per_pkt /
					8 / 1000;
    if ((stream->codec_param.info.max_bps * stream->codec_param.info.frm_ptime *
	stream->codec_param.setting.frm_per_pkt) % 8000 != 0)
    {
	++stream->port.info.bytes_per_frame;
    }

    stream->port.info.format.id = stream->codec_param.info.fmt_id;
    if (stream->codec_param.info.fmt_id == PJMEDIA_FORMAT_L16) {
	stream->port.put_frame = &put_frame;
	stream->port.get_frame = &get_frame;
	stream->port.reset = &reset;
    } else {
	stream->port.info.format.bitrate = stream->codec_param.info.avg_bps;
	stream->port.info.format.vad = (stream->codec_param.setting.vad != 0);
	stream->port.put_frame = &put_frame;
	stream->port.get_frame = &get_frame_ext;
	stream->port.reset = &reset;
    }

    /* If encoder and decoder's ptime are asymmetric, then we need to
     * create buffer on the encoder side. This could happen for example
     * with iLBC 
     */
    if (stream->codec_param.info.enc_ptime!=0 &&
	stream->codec_param.info.enc_ptime!=stream->codec_param.info.frm_ptime)
    {
	unsigned ptime;

	stream->enc_samples_per_pkt = stream->codec_param.info.enc_ptime *
				      stream->codec_param.info.channel_cnt *
				      stream->port.info.clock_rate / 1000;

	/* Set buffer size as twice the largest ptime value between
	 * stream's ptime, encoder ptime, or decoder ptime.
	 */

	ptime = stream->port.info.samples_per_frame * 1000 /
		stream->port.info.clock_rate;

	if (stream->codec_param.info.enc_ptime > ptime)
	    ptime = stream->codec_param.info.enc_ptime;

	if (stream->codec_param.info.frm_ptime > ptime)
	    ptime = stream->codec_param.info.frm_ptime;

	ptime <<= 1;

	/* Allocate buffer */
	stream->enc_buf_size = stream->port.info.clock_rate * ptime / 1000;
	stream->enc_buf = (pj_int16_t*)
			  pj_pool_alloc(pool, stream->enc_buf_size * 2);

    } else {
	stream->enc_samples_per_pkt = stream->port.info.samples_per_frame;
    }


    /* Initially disable the VAD in the stream, to help traverse NAT better */
    stream->vad_enabled = stream->codec_param.setting.vad;
    if (PJMEDIA_STREAM_VAD_SUSPEND_MSEC > 0 && stream->vad_enabled) {
	stream->codec_param.setting.vad = 0;
	stream->ts_vad_disabled = 0;
	stream->codec->op->modify(stream->codec, &stream->codec_param);
	PJ_LOG(4,(stream->port.info.name.ptr,"VAD temporarily disabled"));
    }

    /* Get the frame size */
    stream->frame_size = stream->codec_param.info.max_bps * 
			 stream->codec_param.info.frm_ptime / 8 / 1000;
    if ((stream->codec_param.info.max_bps * stream->codec_param.info.frm_ptime) 
	% 8000 != 0)
    {
	++stream->frame_size;
    }

    /* How many consecutive PLC frames can be generated */
    stream->max_plc_cnt = (MAX_PLC_MSEC+stream->codec_param.info.frm_ptime-1)/
			    stream->codec_param.info.frm_ptime;

#if defined(PJMEDIA_HANDLE_G722_MPEG_BUG) && (PJMEDIA_HANDLE_G722_MPEG_BUG!=0)
    stream->rtp_rx_check_cnt = 5;
    stream->has_g722_mpeg_bug = PJ_FALSE;
    stream->rtp_rx_last_ts = 0;
    stream->rtp_rx_last_cnt = 0;
    stream->rtp_tx_ts_len_per_pkt = stream->enc_samples_per_pkt /
				     stream->codec_param.info.channel_cnt;
    stream->rtp_rx_ts_len_per_frame = stream->port.info.samples_per_frame / 
				       stream->codec_param.info.channel_cnt;

    /* Init RTCP session: */

    /* Special case for G.722 */
    if (info->fmt.pt == PJMEDIA_RTP_PT_G722) {
	pjmedia_rtcp_init(&stream->rtcp, stream->port.info.name.ptr,
			  8000, 
			  160,
			  info->ssrc);
	stream->has_g722_mpeg_bug = PJ_TRUE;
	/* RTP clock rate = 1/2 real clock rate */
	stream->rtp_tx_ts_len_per_pkt >>= 1;
    } else {
	pjmedia_rtcp_init(&stream->rtcp, stream->port.info.name.ptr,
			  info->fmt.clock_rate, 
			  stream->port.info.samples_per_frame, 
			  info->ssrc);
    }
#else
    pjmedia_rtcp_init(&stream->rtcp, stream->port.info.name.ptr,
		      info->fmt.clock_rate, 
		      stream->port.info.samples_per_frame, 
		      info->ssrc);
#endif

    /* Init jitter buffer parameters: */

	if (pjmedia_stream_jitter_buffer_force)
	{
		//Se aplican los parametros definidos con la funcion CORESIP_SetJitterBuffer
		jb_max = pjmedia_stream_jitter_buffer_max_count;
		jb_max_pre = pjmedia_stream_jitter_buffer_max_prefetch;				
		jb_min_pre = pjmedia_stream_jitter_buffer_min_prefetch;
		jb_init = pjmedia_stream_jitter_buffer_prefetch;		
	}
	else
	{
		//Se dejan los parametros por defecto clasicos aplicados en Ulises
		pjmedia_stream_jitter_buffer_adaptive = 1;
		if (info->jb_max >= stream->codec_param.info.frm_ptime)
			jb_max = (info->jb_max + stream->codec_param.info.frm_ptime - 1) /
			stream->codec_param.info.frm_ptime;
		else
			jb_max = gJBufPframes; /*500 / stream->codec_param.info.frm_ptime;*/

		if (info->jb_min_pre >= stream->codec_param.info.frm_ptime)
			jb_min_pre = info->jb_min_pre / stream->codec_param.info.frm_ptime;
		else
			//jb_min_pre = 60 / stream->codec_param.info.frm_ptime;
			jb_min_pre = 1;

		if (info->jb_max_pre >= stream->codec_param.info.frm_ptime)
			jb_max_pre = info->jb_max_pre / stream->codec_param.info.frm_ptime;
		else
		{
			//jb_max_pre = 240 / stream->codec_param.info.frm_ptime;
			jb_max_pre = jb_max * 4 / 5;
		}

		if (info->jb_init >= stream->codec_param.info.frm_ptime)
			jb_init = info->jb_init / stream->codec_param.info.frm_ptime;
		else
			//jb_init = (jb_min_pre + jb_max_pre) / 2;
			jb_init = 0;
	}

    /* Create jitter buffer */
    status = pjmedia_jbuf_create(pool, &stream->port.info.name,
				 stream->frame_size, 
				 stream->codec_param.info.frm_ptime,
				 jb_max, &stream->jb);
    if (status != PJ_SUCCESS)
	goto err_cleanup;

	if (pjmedia_stream_jitter_buffer_adaptive)
	{
		/* Set up jitter buffer */
		pjmedia_jbuf_set_adaptive(stream->jb, jb_init, jb_min_pre, jb_max_pre);
	}
	else
	{
		pjmedia_jbuf_set_fixed(stream->jb, jb_init);
	}

	if (pjmedia_stream_jitter_buffer_discard == 0)
		pjmedia_jbuf_set_discard(stream->jb, PJMEDIA_JB_DISCARD_NONE);
	pjmedia_jbuf_reset(stream->jb);

    /* Create decoder channel: */

    status = create_channel( pool, stream, PJMEDIA_DIR_DECODING, 
			     info->fmt.pt, info, &stream->dec);
    if (status != PJ_SUCCESS)
	goto err_cleanup;


    /* Create encoder channel: */

    status = create_channel( pool, stream, PJMEDIA_DIR_ENCODING, 
			     info->tx_pt, info, &stream->enc);
    if (status != PJ_SUCCESS)
	goto err_cleanup;


    /* Only attach transport when stream is ready. */
    status = pjmedia_transport_attach(tp, stream, &info->rem_addr, 
				      &info->rem_rtcp, 
				      pj_sockaddr_get_len(&info->rem_addr), 
                                      &on_rx_rtp, &on_rx_rtcp);
    if (status != PJ_SUCCESS)
	goto err_cleanup;

    stream->transport = tp;

	status = pjmedia_transport_get_info(tp, &tpinfo);
	if (status == PJ_SUCCESS)
	{
		BOOL QoSResult;
		QOS_VERSION Version;

		// Initialize the QoS version parameter.
		Version.MajorVersion = 1;
		Version.MinorVersion = 0;

		// Get a handle to the QoS subsystem.
		QoSResult = QOSCreateHandle(&Version, &stream->QoSHandle);
		if (QoSResult != TRUE)
		{
			stream->QoSHandle = INVALID_HANDLE_VALUE;
			PJ_LOG(3, (__FILE__, "ERROR: pjmedia_stream_create: QOSCreateHandle failed"));
		}
		else
		{
			// Add socket to flow.
			QOS_FLOWID QoSFlowId;
			QOS_FLOWID QoSFlowId_rtcp;
			QoSFlowId = 0;
			QoSResult = QOSAddSocketToFlow(stream->QoSHandle, tpinfo.sock_info.rtp_sock, (PSOCKADDR)&info->rem_addr, QOSTrafficTypeVoice, QOS_NON_ADAPTIVE_FLOW, &QoSFlowId);
			if (QoSResult != TRUE)
			{
				int werror = WSAGetLastError();
				PJ_LOG(3, (__FILE__, "ERROR: pjmedia_stream_create: RTP Changing DSCP mark QOSAddSocketToFlow failed. Error %d", werror));
			}
			else
			{
				DWORD DSCPValue = PJSIP_RTP_PROTOCOL_DSCP;
				QoSResult = QOSSetFlow(stream->QoSHandle, QoSFlowId, QOSSetOutgoingDSCPValue, sizeof(DSCPValue), &DSCPValue, 0, NULL);
				if (QoSResult != TRUE)
				{
					int werror = WSAGetLastError();
					if (werror == ERROR_ACCESS_DENIED)
					{
						PJ_LOG(3, (__FILE__, "ERROR:  pjmedia_stream_create: RTP QOSSetFlow failed. Error %d. Changing DSCP requires the calling application be a member of the Administrators or the Network Configuration Operators group", werror));
					}
					else
					{
						PJ_LOG(3, (__FILE__, "ERROR:  pjmedia_stream_create: RTP QOSSetFlow failed Changing DSCP mark. Error %d", werror));
					}
				}
			}

			if (tpinfo.sock_info.rtcp_sock != PJ_INVALID_SOCKET)
			{
				QoSFlowId_rtcp = 0;
				QoSResult = QOSAddSocketToFlow(stream->QoSHandle, tpinfo.sock_info.rtcp_sock, (PSOCKADDR)&info->rem_addr, QOSTrafficTypeVoice, QOS_NON_ADAPTIVE_FLOW, &QoSFlowId_rtcp);
				if (QoSResult != TRUE)
				{
					int werror = WSAGetLastError();
					PJ_LOG(3, (__FILE__, "ERROR: pjmedia_stream_create: RTCP Changing DSCP mark QOSAddSocketToFlow failed. Error %d", werror));
				}
				else
				{
					DWORD DSCPValue = PJSIP_RTCP_PROTOCOL_DSCP;
					QoSResult = QOSSetFlow(stream->QoSHandle, QoSFlowId_rtcp, QOSSetOutgoingDSCPValue, sizeof(DSCPValue), &DSCPValue, 0, NULL);
					if (QoSResult != TRUE)
					{
						int werror = WSAGetLastError();
						if (werror == ERROR_ACCESS_DENIED)
						{
							PJ_LOG(3, (__FILE__, "ERROR:  pjmedia_stream_create: RTCP QOSSetFlow failed. Error %d. Changing DSCP requires the calling application be a member of the Administrators or the Network Configuration Operators group", werror));
						}
						else
						{
							PJ_LOG(3, (__FILE__, "ERROR:  pjmedia_stream_create: RTCP QOSSetFlow failed Changing DSCP mark. Error %d", werror));
						}
					}
				}
			}
		}
	}

#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)
    /* Enable RTCP XR and update stream info/config to RTCP XR */
    if (info->rtcp_xr_enabled) {
	int i;

	pjmedia_rtcp_enable_xr(&stream->rtcp, PJ_TRUE);

	/* Set RTCP XR TX interval */
	if (info->rtcp_xr_interval != 0)
	    stream->rtcp_xr_interval = info->rtcp_xr_interval;
	else
	    stream->rtcp_xr_interval = (PJMEDIA_RTCP_INTERVAL + 
				       (pj_rand() % 8000)) * 
				       info->fmt.clock_rate / 1000;

	/* Additional third-party RTCP XR destination */
	if (info->rtcp_xr_dest.addr.sa_family != 0) {
	    stream->rtcp_xr_dest_len = pj_sockaddr_get_len(&info->rtcp_xr_dest);
	    pj_memcpy(&stream->rtcp_xr_dest, &info->rtcp_xr_dest,
		      stream->rtcp_xr_dest_len);
	}

	/* jitter buffer adaptive info */
	i = PJMEDIA_RTCP_XR_JB_ADAPTIVE;
	pjmedia_rtcp_xr_update_info(&stream->rtcp.xr_session, 
				    PJMEDIA_RTCP_XR_INFO_CONF_JBA,
				    i);

	/* Jitter buffer aggressiveness info (estimated) */
	i = 7;
	pjmedia_rtcp_xr_update_info(&stream->rtcp.xr_session, 
				    PJMEDIA_RTCP_XR_INFO_CONF_JBR,
				    i);

	/* Jitter buffer absolute maximum delay */
	i = jb_max * stream->codec_param.info.frm_ptime;
	pjmedia_rtcp_xr_update_info(&stream->rtcp.xr_session, 
				    PJMEDIA_RTCP_XR_INFO_JB_ABS_MAX,
				    i);

	/* PLC info */
	if (stream->codec_param.setting.plc == 0)
	    i = PJMEDIA_RTCP_XR_PLC_DIS;
	else
#if PJMEDIA_WSOLA_IMP==PJMEDIA_WSOLA_IMP_WSOLA
	    i = PJMEDIA_RTCP_XR_PLC_ENH;
#else
	    i = PJMEDIA_RTCP_XR_PLC_DIS;
#endif
	pjmedia_rtcp_xr_update_info(&stream->rtcp.xr_session, 
				    PJMEDIA_RTCP_XR_INFO_CONF_PLC,
				    i);
    }
#endif

    /* Send RTCP SDES */
    len = create_rtcp_sdes(stream, (pj_uint8_t*)stream->enc->out_pkt, 
			   stream->enc->out_pkt_size);
    if (len != 0) {
	pjmedia_transport_send_rtcp(stream->transport, 
				    stream->enc->out_pkt, len);
    }

#if defined(PJMEDIA_STREAM_ENABLE_KA) && PJMEDIA_STREAM_ENABLE_KA!=0
    /* NAT hole punching by sending KA packet via RTP transport. */
    send_keep_alive_packet(stream);
#endif

    /* Success! */
    *p_stream = stream;

    PJ_LOG(5,(THIS_FILE, "Stream %s created", stream->port.info.name.ptr));

    return PJ_SUCCESS;


err_cleanup:
    pjmedia_stream_destroy(stream);
	stream = NULL;
    return status;
}

/* NUCLEO 2014 */
/*
PJ_DEF(void) pjmedia_stream_enable_ec(pj_pool_t *pool, pjmedia_stream * stream)
{
	pj_assert(pool != NULL);
	pj_assert(stream != NULL);

	if (pj_lock_create_recursive_mutex(pool, NULL, &stream->p_echo_lock) == PJ_SUCCESS)
	{
		pjmedia_echo_create2(pool, stream->codec_param.info.clock_rate, stream->codec_param.info.channel_cnt,
			stream->port.info.samples_per_frame, 100, 0, 0, &stream->p_echo);
	}
}
*/
PJ_DEF(void) pjmedia_stream_enable_ec(pj_pool_t *pool, pjmedia_stream * stream, unsigned tail_ms, unsigned latency_ms, unsigned options)
{
	pj_assert(pool != NULL);
	pj_assert(stream != NULL);

	if (pj_lock_create_recursive_mutex(pool, NULL, &stream->p_echo_lock) == PJ_SUCCESS)
	{
		pjmedia_echo_create2(pool, stream->codec_param.info.clock_rate, stream->codec_param.info.channel_cnt,
			stream->port.info.samples_per_frame, tail_ms, latency_ms, options, &stream->p_echo);
	}
}
/* FM */

/*
 * Funci�n para actualizar algunos parametros relacionados con climax
 */
PJ_DEF(void) pjmedia_stream_set_climax_param(pjmedia_stream * stream, pj_bool_t NTP_synchronized)
{
	pj_assert(stream != NULL);

	stream->NTP_synchronized = NTP_synchronized;

	stream->last_rtp_ext_length = 0;  //Esto forzara a que se capture la siguiente extensi�n de cabecera
									
}

/*
 * Funci�n para forzar a que se capture las extensiones de cabecera
 */
PJ_DEF(void) pjmedia_stream_reset_ext_header(pjmedia_stream * stream)
{
	pj_assert(stream != NULL);

	stream->last_rtp_ext_length = 0;  //Esto forzara a que se capture la siguiente extensi�n de cabecera
}


PJ_DEF(void) pjmedia_stream_set_request_MAM(pjmedia_stream * stream)
{
	pj_assert(stream != NULL);

	stream->request_MAM = PJ_TRUE;
}

PJ_DEF(void) pjmedia_stream_send_MAM(pjmedia_stream* stream, pj_uint32_t TQV, pj_uint32_t T1, pj_uint32_t T2, pj_uint16_t Tj1, pj_uint16_t Tid, pj_uint16_t Ts2)
{
	TQV;
	pj_assert(stream != NULL);

	pj_mutex_lock(stream->mam_mutex);
	stream->mam_T1 = T1;
	stream->mam_T2 = T2;
	stream->mam_Tj1 = Tj1;
	stream->mam_Tid = Tid;
	stream->mam_Ts2 = Ts2;
	stream->send_MAM = PJ_TRUE;
	pj_mutex_unlock(stream->mam_mutex);	
}

PJ_DEF(void) pjmedia_stream_force_send_KA_packet(pjmedia_stream * stream)
{
	pj_assert(stream != NULL);

	stream->ka_forced = PJ_TRUE;
}

PJ_DEF(void) pjmedia_stream_disable_keepalives(pjmedia_stream* stream, int on)
{
	pj_assert(stream != NULL);

	if (on != 0) stream->ka_disabled = PJ_TRUE;
	else stream->ka_disabled = PJ_FALSE;
}

PJ_DEF(void) pjmedia_stream_force_set_impairments(pj_pool_t* pool, pjmedia_stream * stream, int Perdidos, int Duplicados, int LatMin, int LatMax)
{
	if (stream == NULL || pool == NULL)
	{
		return;
	}

	pj_lock_acquire(stream->p_latency_lock);

	stream->ImpDat.Perdidos = Perdidos;
	stream->ImpDat.Duplicados = Duplicados;
	stream->ImpDat.LatMin = LatMin;
	stream->ImpDat.LatMax = LatMax;

	if (stream->ImpDat.LatMax != 0 && stream->ImpDat.LatMax_prev == 0)
	{
		//Comienza a aplicarse latencia
		pjmedia_stream_latency_destroy(stream);
		pjmedia_stream_latency_create(pool, stream);
	}
	else if (stream->ImpDat.LatMax == 0)
	{
		//Finaliza el proceso de aplicar latencia
		pjmedia_stream_latency_destroy(stream);
	}

	stream->ImpDat.LatMax_prev = stream->ImpDat.LatMax;

	pj_lock_release(stream->p_latency_lock);
}


PJ_DEF(void) pjmedia_stream_set_audio_flags(pjmedia_stream* stream, pj_uint32_t audio_flags)
{
	if (stream == NULL) return;
	stream->audio_flags = audio_flags;
}

PJ_DEF(void) pjmedia_stream_set_ptt_id(pjmedia_stream* stream, unsigned short ptt_id)
{
	if (stream == NULL) return;
	stream->pttId = ptt_id;
}

PJ_DEF(void) pjmedia_stream_set_radio_ua(pjmedia_stream* stream, pj_bool_t radio_ua)
{
	if (stream == NULL) return;
	stream->radio_ua = radio_ua;
}

PJ_DEF(void) pjmedia_stream_force_no_send_rtp(pjmedia_stream* stream, pj_bool_t force_no_send_rtp)
{
	if (stream == NULL) return;
	stream->force_no_send_rtp = force_no_send_rtp;
}

PJ_DEF(void) pjmedia_stream_GRS_force_ptt_mute_in_RTPRx(pjmedia_stream* stream, pj_uint32_t PttType, pj_uint32_t PttId, pj_bool_t on)
{
	if (on)
	{
		stream->GRS_force_ptt_mute_in_RTPRx = PJ_TRUE;
		stream->GRS_forced_ptt_type_value_in_RTPRx = PttType;
		stream->GRS_forced_ptt_id_value_in_RTPRx = PttId;
	}
	else
	{
		stream->GRS_force_ptt_mute_in_RTPRx = PJ_FALSE;
	}
}

PJ_DEF(void) pjmedia_stream_GRS_force_ptt_in_RTPRx(pjmedia_stream* stream, pj_uint32_t PttType, pj_uint32_t PttId)
{
	if (PttType != RTP_PTT_OFF)
	{
		stream->GRS_force_ptt_in_RTPRx = PJ_TRUE;
		stream->GRS_forced_ptt_type_value_in_RTPRx = PttType;
		stream->GRS_forced_ptt_id_value_in_RTPRx = PttId;
		stream->GRS_force_ptt_mute_in_RTPRx = PJ_FALSE;
	}
	else
	{
		stream->GRS_force_ptt_in_RTPRx = PJ_FALSE;
		stream->GRS_forced_ptt_type_value_in_RTPRx = PttType;
		stream->GRS_forced_ptt_id_value_in_RTPRx = PttId;
	}
}

PJ_DEF(void) pjmedia_stream_GRS_force_SCT_in_RTPRx(pjmedia_stream* stream, pj_bool_t on)
{
	stream->GRS_force_SCT_in_RTPRx = on;
}

PJ_DEF(void) pjmedia_stream_force_PTTS_in_RTPTxRx(pjmedia_stream* stream, pj_bool_t on)
{
	stream->Force_PTTS_in_RTPTxRx = on;
}

PJ_DEF(pj_bool_t) pjmedia_stream_get_GRS_force_ptt_in_RTPRx_confirmed(pjmedia_stream* stream)
{
	return stream->GRS_force_ptt_in_RTPRx_confirmed;
}

PJ_DEF(void) pjmedia_stream_set_ED137version(pjmedia_stream* stream, char ED137version)
{
	stream->ED137version = ED137version;
}

PJ_DEF(void) pjmedia_stream_set_SelCalInProgress(pjmedia_stream* stream, pj_bool_t SelCalInProgress)
{
	stream->SelCalInProgress = SelCalInProgress;
}

PJ_DEF(void) pjmedia_stream_set_is_for_coresip_RTPport(pjmedia_stream* stream, pj_bool_t is_for_coresip_RTPport)
{
	stream->is_for_coresip_RTPport = is_for_coresip_RTPport;
}

/*
 * Destroy stream.
 */
PJ_DEF(pj_status_t) pjmedia_stream_destroy( pjmedia_stream *stream )
{
    unsigned len;
    PJ_ASSERT_RETURN(stream != NULL, PJ_EINVAL);

	pj_lock_acquire(stream->p_latency_lock);
	pjmedia_stream_latency_destroy(stream);
	pj_lock_release(stream->p_latency_lock);
	

#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)
    /* Send RTCP XR on stream destroy */
    if (stream->rtcp.xr_enabled) {
	int i;
	pjmedia_jb_state jb_state;
	void *rtcp_pkt;
	int len;

	/* Update RTCP XR with current JB states */
	pjmedia_jbuf_get_state(stream->jb, &jb_state);
    	    
	i = jb_state.avg_delay;
	pjmedia_rtcp_xr_update_info(&stream->rtcp.xr_session, 
				    PJMEDIA_RTCP_XR_INFO_JB_NOM,
				    i);

	i = jb_state.max_delay;
	pjmedia_rtcp_xr_update_info(&stream->rtcp.xr_session, 
				    PJMEDIA_RTCP_XR_INFO_JB_MAX,
				    i);

	/* Build RTCP XR packet */
	pjmedia_rtcp_build_rtcp_xr(&stream->rtcp.xr_session, 0, 
				   &rtcp_pkt, &len);

	/* Send the RTCP XR to remote address */
	pjmedia_transport_send_rtcp(stream->transport, rtcp_pkt, len);
	
	/* Send the RTCP XR to third-party destination if specified */
	if (stream->rtcp_xr_dest_len) {
	    pjmedia_transport_send_rtcp2(stream->transport, 
					 &stream->rtcp_xr_dest,
					 stream->rtcp_xr_dest_len, 
					 rtcp_pkt, len);
	}
    }
#endif

    /* Send RTCP BYE */
    if (stream->enc && stream->transport) {
	len = create_rtcp_bye(stream, (pj_uint8_t*)stream->enc->out_pkt,
			      stream->enc->out_pkt_size);
	if (len != 0) {
	    pjmedia_transport_send_rtcp(stream->transport, 
					stream->enc->out_pkt, len);
	}
    }

	if (stream->QoSHandle != INVALID_HANDLE_VALUE)
	{
		QOSCloseHandle(stream->QoSHandle);
	}

    /* Detach from transport 
     * MUST NOT hold stream mutex while detaching from transport, as
     * it may cause deadlock. See ticket #460 for the details.
     */
    if (stream->transport) {
	pjmedia_transport_detach(stream->transport, stream);
	stream->transport = NULL;
    }

    /* This function may be called when stream is partly initialized. */
    if (stream->jb_mutex)
	pj_mutex_lock(stream->jb_mutex);


    /* Free codec. */

    if (stream->codec) {
	stream->codec->op->close(stream->codec);
	pjmedia_codec_mgr_dealloc_codec(stream->codec_mgr, stream->codec);
	stream->codec = NULL;
    }

    /* Free mutex */
    
    if (stream->jb_mutex) {
	pj_mutex_destroy(stream->jb_mutex);
	stream->jb_mutex = NULL;
    }

    /* Destroy jitter buffer */
    if (stream->jb)
	pjmedia_jbuf_destroy(stream->jb);

	 if (stream->p_echo)
	 {
		 pj_lock_destroy(stream->p_echo_lock);
		 pjmedia_echo_destroy(stream->p_echo);
	 }

	 if (stream->p_latency_lock)
	 {
		 pj_lock_destroy(stream->p_latency_lock);
	 }

    return PJ_SUCCESS;
}



/*
 * Get the port interface.
 */
PJ_DEF(pj_status_t) pjmedia_stream_get_port( pjmedia_stream *stream,
					     pjmedia_port **p_port )
{
    *p_port = &stream->port;
    return PJ_SUCCESS;
}


/*
 * Get the transport object
 */
PJ_DEF(pjmedia_transport*) pjmedia_stream_get_transport(pjmedia_stream *st)
{
    return st->transport;
}


/*
 * Start stream.
 */
PJ_DEF(pj_status_t) pjmedia_stream_start(pjmedia_stream *stream)
{

    PJ_ASSERT_RETURN(stream && stream->enc && stream->dec, PJ_EINVALIDOP);

    if (stream->enc && (stream->dir & PJMEDIA_DIR_ENCODING)) {
	stream->enc->paused = 0;
	//pjmedia_snd_stream_start(stream->enc->snd_stream);
	PJ_LOG(4,(stream->port.info.name.ptr, "Encoder stream started"));
    } else {
	PJ_LOG(4,(stream->port.info.name.ptr, "Encoder stream paused"));
    }

    if (stream->dec && (stream->dir & PJMEDIA_DIR_DECODING)) {
	stream->dec->paused = 0;
	//pjmedia_snd_stream_start(stream->dec->snd_stream);
	PJ_LOG(4,(stream->port.info.name.ptr, "Decoder stream started"));
    } else {
	PJ_LOG(4,(stream->port.info.name.ptr, "Decoder stream paused"));
    }

    return PJ_SUCCESS;
}


/*
 * Get stream statistics.
 */
PJ_DEF(pj_status_t) pjmedia_stream_get_stat( const pjmedia_stream *stream,
					     pjmedia_rtcp_stat *stat)
{
    PJ_ASSERT_RETURN(stream && stat, PJ_EINVAL);

    pj_memcpy(stat, &stream->rtcp.stat, sizeof(pjmedia_rtcp_stat));
    return PJ_SUCCESS;
}

#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)
/*
 * Get stream extended statistics.
 */
PJ_DEF(pj_status_t) pjmedia_stream_get_stat_xr( const pjmedia_stream *stream,
					        pjmedia_rtcp_xr_stat *stat)
{
    PJ_ASSERT_RETURN(stream && stat, PJ_EINVAL);

    if (stream->rtcp.xr_enabled) {
	pj_memcpy(stat, &stream->rtcp.xr_session.stat, sizeof(pjmedia_rtcp_xr_stat));
	return PJ_SUCCESS;
    }
    return PJ_ENOTFOUND;
}
#endif

/*
 * Get jitter buffer state.
 */
PJ_DEF(pj_status_t) pjmedia_stream_get_stat_jbuf(const pjmedia_stream *stream,
						 pjmedia_jb_state *state)
{
    PJ_ASSERT_RETURN(stream && state, PJ_EINVAL);
    return pjmedia_jbuf_get_state(stream->jb, state);
}

/*
 * Pause stream.
 */
PJ_DEF(pj_status_t) pjmedia_stream_pause( pjmedia_stream *stream,
					  pjmedia_dir dir)
{
    PJ_ASSERT_RETURN(stream, PJ_EINVAL);

    if ((dir & PJMEDIA_DIR_ENCODING) && stream->enc) {
	stream->enc->paused = 1;
	PJ_LOG(4,(stream->port.info.name.ptr, "Encoder stream paused"));
    }

    if ((dir & PJMEDIA_DIR_DECODING) && stream->dec) {
	stream->dec->paused = 1;

	/* Also reset jitter buffer */
	pj_mutex_lock( stream->jb_mutex );
	pjmedia_jbuf_reset(stream->jb);
	pj_mutex_unlock( stream->jb_mutex );

	PJ_LOG(4,(stream->port.info.name.ptr, "Decoder stream paused"));
    }

    return PJ_SUCCESS;
}


/*
 * Resume stream
 */
PJ_DEF(pj_status_t) pjmedia_stream_resume( pjmedia_stream *stream,
					   pjmedia_dir dir)
{
    PJ_ASSERT_RETURN(stream, PJ_EINVAL);

    if ((dir & PJMEDIA_DIR_ENCODING) && stream->enc) {
	stream->enc->paused = 0;
	PJ_LOG(4,(stream->port.info.name.ptr, "Encoder stream resumed"));
    }

    if ((dir & PJMEDIA_DIR_DECODING) && stream->dec) {
	stream->dec->paused = 0;
	PJ_LOG(4,(stream->port.info.name.ptr, "Decoder stream resumed"));
    }

    return PJ_SUCCESS;
}

/*
 * Dial DTMF
 */
PJ_DEF(pj_status_t) pjmedia_stream_dial_dtmf( pjmedia_stream *stream,
					      const pj_str_t *digit_char)
{
    pj_status_t status = PJ_SUCCESS;

    /* By convention we use jitter buffer mutex to access DTMF
     * queue.
     */
    PJ_ASSERT_RETURN(stream && digit_char, PJ_EINVAL);

    /* Check that remote can receive DTMF events. */
    if (stream->tx_event_pt < 0) {
	return PJMEDIA_RTP_EREMNORFC2833;
    }
    
    pj_mutex_lock(stream->jb_mutex);
    
    if (stream->tx_dtmf_count+digit_char->slen >=
	(long)PJ_ARRAY_SIZE(stream->tx_dtmf_buf))
    {
	status = PJ_ETOOMANY;
    } else {
	int i;

	/* convert ASCII digits into payload type first, to make sure
	 * that all digits are valid. 
	 */
	for (i=0; i<digit_char->slen; ++i) {
	    unsigned pt;
	    int dig = pj_tolower(digit_char->ptr[i]);

	    if (dig >= '0' && dig <= '9')
	    {
		pt = dig - '0';
	    } 
	    else if (dig >= 'a' && dig <= 'd')
	    {
		pt = dig - 'a' + 12;
	    }
	    else if (dig == '*')
	    {
		pt = 10;
	    }
	    else if (dig == '#')
	    {
		pt = 11;
	    }
	    else
	    {
		status = PJMEDIA_RTP_EINDTMF;
		break;
	    }

	    stream->tx_dtmf_buf[stream->tx_dtmf_count+i].event = pt;
	    stream->tx_dtmf_buf[stream->tx_dtmf_count+i].duration = 0;
	}

	if (status != PJ_SUCCESS)
	    goto on_return;

	/* Increment digit count only if all digits are valid. */
	stream->tx_dtmf_count += (int)digit_char->slen;
    }

on_return:
    pj_mutex_unlock(stream->jb_mutex);

    return status;
}


/*
 * See if we have DTMF digits in the rx buffer.
 */
PJ_DEF(pj_bool_t) pjmedia_stream_check_dtmf(pjmedia_stream *stream)
{
    return stream->rx_dtmf_count != 0;
}


/*
 * Retrieve incoming DTMF digits from the stream's DTMF buffer.
 */
PJ_DEF(pj_status_t) pjmedia_stream_get_dtmf( pjmedia_stream *stream,
					     char *digits,
					     unsigned *size)
{
    PJ_ASSERT_RETURN(stream && digits && size, PJ_EINVAL);

    pj_assert(sizeof(stream->rx_dtmf_buf[0]) == 0);

    /* By convention, we use jitter buffer's mutex to access DTMF
     * digits resources.
     */
    pj_mutex_lock(stream->jb_mutex);

    if (stream->rx_dtmf_count < *size)
	*size = stream->rx_dtmf_count;

    if (*size) {
	pj_memcpy(digits, stream->rx_dtmf_buf, *size);
	stream->rx_dtmf_count -= *size;
	if (stream->rx_dtmf_count) {
	    pj_memmove(stream->rx_dtmf_buf,
		       &stream->rx_dtmf_buf[*size],
		       stream->rx_dtmf_count);
	}
    }

    pj_mutex_unlock(stream->jb_mutex);

    return PJ_SUCCESS;
}


/*
 * Set callback to be called upon receiving DTMF digits.
 */
PJ_DEF(pj_status_t) pjmedia_stream_set_dtmf_callback(pjmedia_stream *stream,
				 void (*cb)(pjmedia_stream*, 
					    void *user_data, 
					    int digit), 
				 void *user_data)
{
    PJ_ASSERT_RETURN(stream, PJ_EINVAL);

    /* By convention, we use jitter buffer's mutex to access DTMF
     * digits resources.
     */
    pj_mutex_lock(stream->jb_mutex);

    stream->dtmf_cb = cb;
    stream->dtmf_cb_user_data = user_data;

    pj_mutex_unlock(stream->jb_mutex);

    return PJ_SUCCESS;
}

